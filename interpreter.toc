
(add-ns ev (module "eval.toc"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "6b65dea"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "40c1c4d"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "dc80090"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e7a489b"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "f7b5678"))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))

;; TODO: this generates bad code
;; (defn interp-impl [impl-name impl-fn]
;;   (reify
;;     Stringable
;;     (string-list [_]
;;       (list (str impl-name)))

;;     Eq
;;     (=* [x y]
;;       (print-err 'WTF!!!)
;;       nothing)

;;     ev/Evaluator
;;     (ev/eval [x]
;;       (sm/state-maybe x))

;;     (ev/apply-fn [_ args]
;;       (print-err 'perhaps-here impl-name)
;;       (impl-fn args))))

(deftype interp-impl [impl-name impl-fn]
  Stringable
  (string-list [_]
    (list (str impl-name)))

  Eq
  (=* [x y]
    nothing)

  ev/Evaluator
  (ev/eval [x]
    (sm/state-maybe x))

  (ev/apply-fn [_ args]
    (apply impl-fn (seq args))))

(def interp-abort (interp-impl 'interp-abort
                               (fn [x y]
                                 (zero sm/state-maybe))))

(def interp-symbols {'Integer (ev/TypeMap {IntegerType #{}})
                     'StringBuffer (ev/TypeMap {StringBufferType #{}})
                     'SubString (ev/TypeMap {SubStringType #{}})
                     'FnArity (ev/TypeMap {FnArityType #{}})
                     'Fn (ev/TypeMap {FunctionType #{}})
                     'List (ev/TypeMap {ListType #{}})
                     'Maybe (ev/TypeMap {MaybeType #{}})
                     'Vector (ev/TypeMap {VectorType #{}})
                     'Symbol (ev/TypeMap {SymbolType #{}})
                     'BitmapIndexedNode (ev/TypeMap {BitmapIndexedType #{}})
                     'ArrayNode (ev/TypeMap {ArrayNodeType #{}})
                     'HashCollisionNode (ev/TypeMap {HashCollisionNodeType #{}})
                     'Promise (ev/TypeMap {PromiseType #{}})
                     'Future (ev/TypeMap {FutureType #{}})
                     'Agent (ev/TypeMap {AgentType #{}})
                     'Opaque (ev/TypeMap {OpaqueType #{}})
                     'abort interp-abort})

(defn interp-file [script-file args]
  (let [core-syms (reduce (for [proto (keys protocols)
                                proto-fn (keys (extract (get protocols proto)))]
                            proto-fn)
                          (comp symbols interp-symbols)
                          (fn [syms proto-fn]
                            (assoc syms proto-fn (ev/ProtoDispatcher (rdr/tag proto-fn) ""
                                                                     ev/empty-state))))
        core-protos (reduce (seq protocols) {}
                            (fn [m [_ proto]] 
                              (reduce (seq proto) m
                                      (fn [m [proto-sym impls]]
                                        (assoc m
                                          (rdr/tag proto-sym)
                                          (map-vals impls (fn [impl-map]
                                                            (map-vals impl-map
                                                                      (fn [arity]
                                                                        (ev/wrap-arity arity (str proto-sym)))))))))))
        types-count (reduce (for [protos (vals core-protos)
                                  arities (vals protos)
                                  type-num (keys arities)]
                              type-num)
                            0 (fn [max n]
                                (either (> n max)
                                        max)))
        eval-state (-> ev/empty-state
                       (assoc-in [.ns ""] (ev/EvalNamespace {} core-syms core-protos))
                       (assoc-in [.ns script-file] (ev/EvalNamespace {} {} {}))
                       (.type-count (inc types-count))
                       (.file-name script-file))]
    (or (for [file-in (fio/file-in script-file)
              asts (ev/parse {'file-name script-file
                              'line-number 1}
                             (lazy-list file-in))]
          (flat-map (flat-map ((ev/eval asts) eval-state)
                              first)
                    last))
        (maybe -1))))

