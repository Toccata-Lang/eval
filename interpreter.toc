
(add-ns ev (module "eval.toc"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "6b65dea"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "dc80090"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e7a489b"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "f7b5678"))

(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))

;; TODO: this generates bad code
;; (defn interp-impl [impl-name impl-fn]
;;   (reify
;;     Stringable
;;     (string-list [_]
;;       (list (str impl-name)))

;;     Eq
;;     (=* [x y]
;;       (print-err 'WTF!!!)
;;       nothing)

;;     ev/Evaluator
;;     (ev/eval [x]
;;       (sm/state-maybe x))

;;     (ev/apply-fn [_ args]
;;       (print-err 'perhaps-here impl-name)
;;       (impl-fn args))))

(deftype CompiledNs [ns-sym syms protos]
  Stringable
  (string-list [_]
    (list "<CompiledNS " (str ns-sym) ">")))

(deftype interp-impl [impl-name impl-fn]
  Stringable
  (string-list [_]
    (list (str impl-name)))

  Eq
  (=* [x y]
    nothing)

  ev/Evaluator
  (ev/eval [x]
    (sm/state-maybe x))

  (ev/apply-fn [_ args]
    (apply impl-fn (seq args))))

(def interp-abort (interp-impl 'interp-abort
                               (fn [x y]
                                 (zero sm/state-maybe))))

(def interp-symbols {'Integer (ev/TypeMap {IntegerType #{}})
                     'StringBuffer (ev/TypeMap {StringBufferType #{}})
                     'SubString (ev/TypeMap {SubStringType #{}})
                     'FnArity (ev/TypeMap {FnArityType #{}})
                     'Fn (ev/TypeMap {FunctionType #{}})
                     'List (ev/TypeMap {ListType #{}})
                     'Maybe (ev/TypeMap {MaybeType #{}})
                     'Vector (ev/TypeMap {VectorType #{}})
                     'Symbol (ev/TypeMap {SymbolType #{}})
                     'BitmapIndexedNode (ev/TypeMap {BitmapIndexedType #{}})
                     'ArrayNode (ev/TypeMap {ArrayNodeType #{}})
                     'HashCollisionNode (ev/TypeMap {HashCollisionNodeType #{}})
                     'Promise (ev/TypeMap {PromiseType #{}})
                     'Future (ev/TypeMap {FutureType #{}})
                     'Agent (ev/TypeMap {AgentType #{}})
                     'Opaque (ev/TypeMap {OpaqueType #{}})
                     'abort interp-abort
                     'bpre print-err
                     'prefs prefs})

(defn make-compiled-ns [path syms protos]
  (assert (instance? String path))

  (let [ns-syms (reduce (for [proto (keys protos)
                              proto-fn (keys (extract (get protos proto)))]
                          proto-fn)
                        syms
                        (fn [syms proto-fn]
                          (assoc syms proto-fn (ev/ProtoDispatcher (rdr/tag proto-fn) path ev/empty-state))))
        ns-protos (reduce (seq protos) {}
                          (fn [m [_ proto]] 
                            (reduce (seq proto) m
                                    (fn [m [proto-sym impls]]
                                      (assoc m
                                        (rdr/tag proto-sym)
                                        (map-vals impls
                                                  (fn [impl-map]
                                                    (map-vals impl-map
                                                              (fn [arity]
                                                                (ev/wrap-arity arity (str proto-sym)))))))))))]
    (ev/EvalNamespace path {} ns-syms ns-protos)))

(defn interp-file [script-file script-dir base-imports args]
  (let [core-syms (reduce (for [proto (keys protocols)
                                proto-fn (keys (extract (get protocols proto)))]
                            proto-fn)
                          (comp symbols interp-symbols)
                          (fn [syms proto-fn]
                            (assoc syms proto-fn (ev/ProtoDispatcher (rdr/tag proto-fn) ""
                                                                     ev/empty-state))))
        core-ns (make-compiled-ns "" (comp symbols interp-symbols) protocols)
        base-imports (reduce base-imports {}
                             (fn [base-imports compiled]
                               (assoc base-imports
                                 (.ns-sym compiled) (make-compiled-ns (str (.ns-sym compiled))
                                                                      (.syms compiled)
                                                                      (.protos compiled)))))
        types-count (reduce (for [ns (conj (vals base-imports) core-ns)
                                  protos (vals (.impls ns))
                                  arities (vals protos)
                                  type-num (keys arities)]
                              type-num)
                            0 (fn [max n]
                                (either (> n max)
                                        max)))
        ns-state (reduce (conj (vals base-imports) core-ns) {}
                         (fn [nss ns]
                           (assoc nss (.path ns) ns)))
        base-imports (map-vals base-imports .syms)
        eval-state (-> ev/empty-state
                       (.ns ns-state)
                       (assoc-in [.ns script-file] (ev/EvalNamespace script-file base-imports {} {}))
                       (.base-imports base-imports)
                       (.type-count (inc types-count))
                       (.script-dir script-dir)
                       (.file-name script-file))]
    (or (for [file-in (fio/file-in script-file)
              asts (ev/parse {'file-name script-file
                              'line-number 1}
                             (lazy-list file-in))]
          (flat-map (flat-map ((ev/eval asts) eval-state)
                              first)
                    last))
        (maybe -1))))
