
(add-ns ev (module "eval.toc"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e7a489b"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "4893cbf"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "ba18227"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "ecde30b"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "7690cd3"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "c89ab00"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "40c1c4d"))
(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))

(def type-nums {'Integer {IntegerType #{}}
                'StringBuffer {StringBufferType #{}}
                'SubString {SubStringType #{}}
                'FnArity {FnArityType #{}}
                'Fn {FunctionType #{}}
                'List {ListType #{}}
                'Maybe {MaybeType #{}}
                'Vector {VectorType #{}}
                'Symbol {SymbolType #{}}
                'BitmapIndexedNode {BitmapIndexedType #{}}
                'ArrayNode {ArrayNodeType #{}}
                'HashCollisionNode {HashCollisionNodeType #{}}
                'Promise {PromiseType #{}}
                'Future {FutureType #{}}
                'Agent {AgentType #{}}
                'Opaque {OpaqueType #{}}})

(def interp-list-map (reify
                       Stringable
                       (string-list [_]
                         (list "interp-list-map"))

                       Eq
                       (=* [x y]
                         nothing)

                       ev/Evaluator
                       (ev/eval* [x]
                         (sm/state-maybe x))

                       (ev/apply-fn [_ [l f]]
                         (ev/traverse (reverse l) (fn [x]
                                                    (ev/apply-fn f (list x)))))))

(def interp-maybe-map (reify
                        Stringable
                        (string-list [_]
                          (list "interp-maybe-map"))

                        Eq
                        (=* [x y]
                          nothing)

                        ev/Evaluator
                        (ev/eval* [x]
                          (sm/state-maybe x))

                        (ev/apply-fn [_ [mv f]]
                          (either (map mv (fn [x]
                                            (map (ev/apply-fn f (list x))
                                                 maybe)))
                                  (sm/state-maybe nothing)))))

(def interp-maybe-apply (reify
                          Stringable
                          (string-list [_]
                            (list "interp-maybe-apply"))

                          Eq
                          (=* [x y]
                            nothing)

                          ev/Evaluator
                          (ev/eval* [x]
                            (sm/state-maybe x))

                          (ev/apply-fn [_ [mf mvs]]
                            (either (apply* (map mf (fn [f]
                                                      (fn [& args]
                                                        (map (ev/apply-fn f args)
                                                             maybe))))
                                            mvs)
                                    (sm/state-maybe nothing)))))

(def interp-abort (reify
                    Stringable
                    (string-list [_]
                      (list "interp-abort"))

                    Eq
                    (=* [x y]
                      nothing)

                    ev/Evaluator
                    (ev/eval* [x]
                      (zero sm/state-maybe))

                    (ev/apply-fn [x y]
                      (zero sm/state-maybe))))

(def interp-apply* (reify
                     Stringable
                     (string-list [_]
                       (list "interp-apply*"))

                     Eq
                     (=* [x y]
                       nothing)

                     ev/Evaluator
                     (ev/eval* [x]
                       (sm/state-maybe x))

                     (ev/apply-fn [_ [mf mvs]]
                       (either (for [_ (or (instance? Fn mf)
                                           (instance? ast/fn-ast mf))
                                     args-seq (or (empty? mvs)
                                                  (last mvs))]
                                 (let [args-prefix (butlast mvs)]
                                   (either (and (instance? Sequence args-seq)
                                                (maybe (for [target (ev/eval* mf)
                                                             args (ev/eval* (comp args-prefix args-seq))
                                                             r (ev/apply-fn target args)]
                                                         r)))
                                           (do
                                             (print-err "The final argument when using 'apply' on a function"
                                                        "must be either a Vector or a List.")
                                             (zero sm/state-maybe)))))
                               (for [target (ev/eval* mf)
                                     args (ev/eval* mvs)
                                     r (ev/apply-fn target args)]
                                 r)))))

(def symbols {'empty-list empty-list
              'empty-vector empty-vector
              'maybe maybe
              'nothing nothing
              'reified-type-args reified-type-args
              'reified-get-type reified-get-type
              'new-type-value new-type-value
              'make-value make-value
              'list-count list-count
              'mutate-vect-conj mutate-vect-conj
              'list-concat list-concat
              'add-numbers add-numbers
              'str-malloc str-malloc
              'subtract-numbers subtract-numbers
              'mult-numbers mult-numbers
              'rem rem
              'vect-count vect-count
              'emptyBMI emptyBMI
              'bit-and bit-and
              'bit-or bit-or
              'deliver deliver
              'delivered delivered
              'cons cons
              'sha1-init sha1-init
              'sha1-finalize sha1-finalize
              'address-of address-of
              'identical identical
              'str-append str-append
              'pr* pr*
              'pr-err* pr-err*
              'escape-chars escape-chars
              'char char
              'char-code char-code
              'subs subs
              'symbol symbol
              'sha1-update-type sha1-update-type
              'add-promise-action add-promise-action
              'promise promise
              'future future
              'thread-id thread-id
              'deliver-future deliver-future
              'add-future-action add-future-action
              'Integer (reify
                         Type
                         (instance? [_ x]
                           (and (=* IntegerType (get-type x))
                                (maybe x))))
              'List (reify
                      Type
                      (instance? [_ x]
                        (and (=* ListType (get-type x))
                             (maybe x))))
              'Maybe (reify
                       Type
                       (instance? [_ x]
                         (and (=* MaybeType (get-type x))
                              (maybe x))))
              'Symbol (reify
                        Type
                        (instance? [_ x]
                          (and (=* SymbolType (get-type x))
                               (maybe x))))
              'Vector (reify
                        Type
                        (instance? [_ x]
                          (and (=* VectorType (get-type x))
                               (maybe x))))
              'Fn (reify
                    Type
                    (instance? [_ x]
                      (and (=* FunctionType (get-type x))
                           (maybe x))))
              'Promise (reify
                         Type
                         (instance? [_ x]
                           (and (=* PromiseType (get-type x))
                                (maybe x))))
              'Future (reify
                        Type
                        (instance? [_ x]
                          (and (=* FutureType (get-type x))
                               (maybe x))))
              'Agent (reify
                       Type
                       (instance? [_ x]
                         (and (=* AgentType (get-type x))
                              (maybe x))))

              'apply* interp-apply*
              'list-map interp-list-map
              'maybe-map interp-maybe-map
              'maybe-apply interp-maybe-apply
              'abort interp-abort

              'integer-str str
              'add-ints add-numbers
              'int= =*
              })

(def eval-state (ev/EvalState {"" (ev/EvalNamespace {} symbols {})}
                              {} type-nums core-protocols ""))

(defn interp-file [state file]
  (println file)
  (or (for [file-in (fio/file-in file)
            asts (ev/parse {'file-name file
                            'line-number 1}
                           (lazy-list file-in))
            [result _] (ev/eval asts (-> state
                                         (assoc-in [.ns file] (ev/EvalNamespace {} {} {}))
                                         (.file-name file)))
            result (last result)]
        (println "\nresult:" result "\n"))
      (maybe (print-err "FAIL!!!\n"))))

(main [[_ & files]]
  (for [file-in (fio/file-in path-to-core)
        asts (ev/parse {'file-name path-to-core
                        'line-number 1}
                       (lazy-list file-in))
        [_ state] (ev/eval asts eval-state)]
    (do
      (map files (partial interp-file state))
      (println 'done))))
