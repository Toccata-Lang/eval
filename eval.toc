
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "3435b1b"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "6673103"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "1c09660"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "1e280ff"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "f655efc"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "ffd6095"))

(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))

(def *max-call-depth* 500)

(defn init [f]
  (inline C "
universalProtoFn = (Value *)f_0;
// TODO: dec_and_free(f_0, 1);
return(nothing);
"))

(defn abort-interp [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               nothing)))

;; useful for debugging
(defn debug [& args]
  (sm/new-sm (fn [s]
               (apply print-err args)
               (maybe ['_ s]))))

(defn ast-location-str [x]
  (str (ast/file-name x) ": "
       (ast/line-number x)))

(deftype EvalNamespace [path imports syms import-paths]
  (assert (instance? HashMap imports))
  (assert (instance? HashMap syms))

  Stringable
  (string-list [_]
    (list "(EvalNamespace" (str path) " " (to-str (keys syms)))))

(deftype EvalState [ns type-count file-name call-depth command-line script-dir base-imports]
  (assert (instance? HashMap ns))
  (assert (instance? Integer type-count))
  (assert (instance? String file-name))
  (assert (instance? Integer call-depth))
  (assert (instance? Vector command-line))

  Stringable
  (string-list [_] (list "<EvalState>")))

(def empty-state (EvalState {} 0 "" 0 [] "" {}))

(defn get-syms []
  (flat-map (sm/get-val .file-name)
            (fn [ns-path]
              (sm/get-in-val [.ns ns-path .syms]))))


(defn set-syms [syms]
  (flat-map (sm/get-val .file-name)
            (fn [ns-path]
              (sm/assoc-in-val [.ns ns-path .syms] syms))))

;; TODO: this is a stupid workaround for a stupid compiler bug
(def traverse)

(defprotocol Evaluator
  (traverse [coll f]
    ;; traverses a Sequence, applying 'f' to each item
    ;; 'f' must take one value and return a 'state-maybe' value
    (assert-result x (instance? sm/new-sm x)))

  (untag [s]
    ;; remove the tag information from a symbol
    s)

  (update-state [x _]
    x)

  (get-state [x])
  (set-fields [x new-fields])

  (bind [_ _]
    ;; bind a value to a symbol in the .syms field of the current namespace
    ;; also destructures a params-ast to a sequence of values
    (assert-result r (instance? sm/state-maybe r)))

  (uniqueify [_]
    ;; replace arguments with unique symbols
    (assert-result r (instance? sm/state-maybe r)))

  (bind-fields [_]
    ;; bind the fields of a ReifiedValue to the field names
    (assert-result r (instance? sm/state-maybe r))
    (sm/state-maybe '_))

  (lookup-sym [s]
    ;; retrieve the value bound to 's'
    (assert-result r (instance? sm/state-maybe r))
    (zero sm/state-maybe))

  (apply-fn [f args]
    ;; evaluate 'f' given paramters bound to 'args'
    (assert-result r (instance? sm/state-maybe r))

    (for [args (traverse (seq args) eval)]
      (apply f args)))

  (eval-def [x]
    (assert-result r (instance? sm/state-maybe r))
    (wrap sm/zero-sm x))

  (eval [x]
    ;; evaluate an expression 'x' to produce a value (and side effects)
    (assert-result r (instance? sm/state-maybe r))
    (wrap sm/zero-sm x)))

(extend-type sm/new-sm
  Evaluator
  (apply-fn [mv [state]]
    (wrap sm/zero-sm (mv state))))

(def parse (rd/parser
            (grmr/all (grmr/optional rdr/shebang)
                      (grmr/none-or-more
                       (grmr/any rdr/read-def
                                 rdr/read-defn
                                 rdr/read-defprotocol
                                 rdr/read-main
                                 rdr/read-extend-type
                                 rdr/read-deftype
                                 rdr/read-block-comment
                                 rdr/read-add-ns
                                 rdr/read-expr)))))

(deftype ConstrainedFn [value constraints]
  Stringable
  (string-list [_]
    (list "<ConstrainedFn " (str value) " " (str constraints) ">"))

  Container
  (apply [_ xs]
    (apply value xs)))

(deftype Constrained [value constraints]
  Stringable
  (string-list [_]
    (list "<Constrained " (str value) " " (str constraints) ">"))

  Container
  (apply [_ xs]
    (apply value xs)))

(deftype Thunk [ast es]
  Stringable
  (string-list [_]
    (list "<Thunk " (str (.fn-sym ast)) ">"))

  Evaluator
  (update-state [x new-state]
    (.es x new-state))

  (apply-fn [_ args]
    (apply-fn ast args))

  (eval [t]
    (sm/new-sm (fn [s]
                 (maybe [(fn [& args]
                           (-> t
                               (.es s)
                               (apply args)))
                         s]))))

  Container
  (apply [_ args]
    (either (flat-map ((apply-fn ast args) es)
                      first)
            (abort)))

  Function
  (invoke [v]
    (either (flat-map ((apply-fn ast []) es)
                      first)
            (abort)))

  (invoke [v a]
    (either (flat-map ((apply-fn ast [a]) es)
                      first)
            (abort)))

  (invoke [v a b]
    (either (flat-map ((apply-fn ast [a b]) es)
                      first)
            (abort)))

  (invoke [v a b c]
    (either (flat-map ((apply-fn ast [a b c]) es)
                      first)
            (abort)))

  (invoke [v a b c d]
    (either (flat-map ((apply-fn ast [a b c d]) es)
                      first)
            (abort)))

  (invoke [v a b c d e]
    (either (flat-map ((apply-fn ast [a b c d e]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f]
    (either (flat-map ((apply-fn ast [a b c d e f]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f g]
    (either (flat-map ((apply-fn ast [a b c d e f g]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f g h]
    (either (flat-map ((apply-fn ast [a b c d e f g h]) es)
                      first)
            (abort))))

(deftype ProtoDispatcher [prototype-name path impls es]
  (assert (instance? rdr/tagged-symbol prototype-name))
  (assert (instance? String path))
  (assert (instance? HashMap impls))
  (assert (instance? EvalState es))

  Type
  (type-name [_]
    (str "ProtoDispatcher: " prototype-name))

  Stringable
  (string-list [_]
    (list (str prototype-name)))

  Container
  (apply [disp args]
    (either (flat-map ((apply-fn disp args) es)
                      first)
            (abort)))

  Function
  (invoke [v]
    (either (flat-map ((apply-fn v []) es)
                      first)
            (abort)))

  (invoke [v a]
    (either (flat-map ((apply-fn v [a]) es)
                      first)
            (abort)))

  (invoke [v a b]
    (either (flat-map ((apply-fn v [a b]) es)
                      first)
            (abort)))

  (invoke [v a b c]
    (either (flat-map ((apply-fn v [a b c]) es)
                      first)
            (abort)))

  (invoke [v a b c d]
    (either (flat-map ((apply-fn v [a b c d]) es)
                      first)
            (abort)))

  (invoke [v a b c d e]
    (either (flat-map ((apply-fn v [a b c d e]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f]
    (either (flat-map ((apply-fn v [a b c d e f]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f g]
    (either (flat-map ((apply-fn v [a b c d e f g]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f g h]
    (either (flat-map ((apply-fn v [a b c d e f g h]) es)
                      first)
            (abort)))

  Evaluator
  (eval [x]
    (sm/new-sm (fn [s]
                 (maybe [(.es x s) s])))))

(defn get-impl [sym type-num]
  (for [disp (lookup-sym sym)
        _ (either (map (instance? ProtoDispatcher disp) sm/state-maybe)
                  (abort-interp (str "'" sym "'") "is not a protocol function."))
        result (sm/get-in-val [.ns (.path disp) .syms (.prototype-name disp) .impls type-num])]
    result))

(defn sha1-update-type-num [type-num ctxt]
  (assert (instance? Integer type-num))
  (inline C Integer "
  Sha1Update(((Opaque *)ctxt_1)->ptr, (void *)&((Integer *)type_num_0)->numVal, 8);
  dec_and_free(type_num_0, 1);
  return(ctxt_1);
"))

(deftype ReifiedValue [type-sym type-num fields field-names impls es]
  (assert (instance? Maybe type-sym))
  (assert (instance? Integer type-num))
  (assert (instance? Vector fields))
  (assert (instance? Vector field-names))
  (assert (instance? HashMap impls))
  (assert (instance? EvalState es))

  Hashable
  (sha1-update [x ctxt]
    (sha1-update-type-num (get-type x) ctxt)
    (sha1-update fields ctxt))

  (sha1 [v]
    (either (flat-map ((for [impl (get-impl (rdr/tag 'sha1) type-num)
                             _ (bind-fields v)
                             result (apply-fn impl [v])]
                         result)
                       es)
                      first)
            (sha1-finalize (sha1-update v (sha1-init)))))

  Eq
  (=* [x y]
    (either (flat-map ((for [args (eval (list x y))
                             impl (get-impl (rdr/tag '=*) type-num)
                             _ (bind-fields x)
                             r (apply-fn impl args)]
                         r)
                       es)
                      first)
            (and (= type-num (get-type y))
                 (= fields (type-args y))
                 (maybe x))))

  Type
  (type-name [_]
    (str (either type-sym
                 type-num)))

  (type-mapping [_]
    {type-num (set fields)})

  (type-args [_]
    fields)

  (get-type [_]
    type-num)

  Evaluator
  (get-state [_]
    es)

  (set-fields [x new-fields]
    (ReifiedValue type-sym type-num new-fields field-names impls es))

  (eval [rv]
    (for [curr-state (sm/update-state identity)
          new-impls (traverse (seq impls)
                              (fn [[sym impl]]
                                (for [new-impl (eval-def impl)]
                                  {sym new-impl})))]
      (-> rv
          (.impls (comp* {} new-impls))
          (.es curr-state))))

  (apply-fn [disp-arg args]
    (flat-map (sm/when (get impls (rdr/tag 'invoke)))
              (fn [impl]
                (apply-fn impl (cons disp-arg (seq args))))))

  (bind-fields [_]
    (either (and (empty? fields)
                 (maybe (wrap sm/zero-sm '_)))
            (traverse (zip-lists (seq field-names)
                                 (seq fields))
                      (fn [[name value]]
                        (bind name value))))))

(extend-type ProtoDispatcher
  Evaluator
  (apply-fn [disp args]
    (let [prototype-name (.prototype-name disp)
          path (.path disp)]
      (either (for [disp-arg (first args)]
                (let [disp-arg (untag disp-arg)
                      type-num (get-type disp-arg)]
                  (for [disp (sm/get-in-val [.ns path .syms prototype-name])
                        impl (comp (sm/when (or (and (instance? ReifiedValue disp-arg)
                                                     (get-in disp-arg [.impls (rdr/tag prototype-name)]))
                                                (get-in disp [.impls type-num])
                                                (get-in disp [.impls 0])))
                                   (abort-interp "Could not find implementation of"
                                                 (str "'" prototype-name "'") "for type"
                                                 (str "'" (type-name disp-arg) "' with")
                                                 (count args) "arguments."))
                        syms (get-syms)
                        _ (bind-fields disp-arg)
                        r (apply-fn impl (comp [disp-arg] (rest args)))
                        _ (set-syms syms)]
                    r)))
              (abort-interp "At least one argument must be passed to protocol function"
                            (str "'" prototype-name "'"))))))

(deftype TypeMap [type-map]
  Stringable
  (string-list [_]
    (list "<TypeMap " (str type-map) ">"))

  Composition
  (comp* [x xs]
    (TypeMap (comp* type-map (map xs type-mapping))))

  Type
  (type-mapping [_]
    type-map)
  
  (instance? [_ v]
    (or (and (get type-map FunctionType)
             (or (instance? ast/fn-ast v)
                 (instance? Thunk v)))
        (and (get type-map (get-type v))
             (maybe v)))))

(deftype TypeConstructor [type-sym type-num reified-type field-names type-map es]
  (assert (instance? rdr/tagged-symbol type-sym))
  (assert (instance? Integer type-num))
  (assert (instance? HashMap type-map))

  Type
  (type-name [_]
    (str "*" type-sym " constructor*"))

  (type-mapping [_]
    type-map)

  (get-type [_]
    type-num)

  Stringable
  (string-list [_]
    (list "<ValueConstructor " (str type-sym) " " (str field-names) ">"))

  Composition
  (comp* [x xs]
    (TypeMap (comp* type-map (map xs type-mapping))))

  Evaluator
  (get-state [_]
    es)

  (eval [x]
    (sm/new-sm (fn [s]
                 (maybe [(.es x s) s]))))

  (apply-fn [f args]
    (for [s (sm/update-state identity)]
      (ReifiedValue (maybe type-sym)
                    reified-type
                    (vec args) field-names {} s))))

(defn universal-proto-fn [path fn-sym disp-arg & args]
  (assert (instance? String path))
  (assert (instance? Symbol fn-sym))

  (let [path (either (and (= "core" path)
                          (maybe ""))
                     path)]
    (and (or (instance? ReifiedValue disp-arg)
             (instance? TypeConstructor disp-arg))
         (flat-map ((either (map (get-in disp-arg [.impls (rdr/tag fn-sym)])
                                 (fn [impl]
                                   (for [_ (bind-fields disp-arg)
                                         r (apply-fn impl (cons disp-arg args))]
                                     r)))
                            (for [curr-file (sm/get-val .file-name)
                                  ns-prefix (sm/get-in-val [.ns curr-file .import-paths path])
                                  impl (sm/get-in-val [.ns (str ns-prefix) .syms (rdr/tag fn-sym) .impls
                                                       (get-type disp-arg)])
                                  _ (bind-fields disp-arg)
                                  result (apply-fn impl (cons disp-arg args))]
                              result))
                    (get-state disp-arg))
                   first))))

;; TODO: remove need for or decide to keep
(def fn-thing (comp Fn
                    Thunk
                    ReifiedValue
                    ProtoDispatcher
                    TypeConstructor
                    ast/fn-ast))

(defn set-proto-impl [sym type-num impl]
  (assert (instance? rdr/tagged-symbol sym))

  (for [curr-file (sm/get-val .file-name)
        disp (either (map (.ns sym)
                          (fn [ns-sym]
                            (sm/get-in-val [.ns curr-file .imports (rdr/tag ns-sym) (rdr/tag (.base sym))])))
                     (comp (sm/get-in-val [.ns curr-file .syms sym])
                           (sm/get-in-val [.ns "" .syms sym])))
        _ (sm/assoc-in-val [.ns (.path disp) .syms (rdr/tag (.base sym)) .impls type-num]
                           impl)]
    '_))

(extend-type List
  Evaluator
  (traverse [asts f]
    (apply (wrap sm/zero-sm list)
           (-> asts
               (remove (fn [x]
                         (instance? ast/block-comment-ast x)))
               (map f))))

  (eval-def [v]
    (traverse v eval-def))

  (eval [v]
    (traverse v eval)))

(extend-type Vector
  Evaluator
  (traverse [asts f]
    (-> asts
        (remove (fn [x]
                  (instance? ast/block-comment-ast x)))
        reverse
        (reduce (sm/state-maybe empty-vector)
                (fn [v ast]
                  (flat-map (f ast)
                            (fn [emitted]
                              (map v (fn [v]
                                       (conj v emitted)))))))
        (map reverse)))

  (eval-def [v]
    (traverse v eval-def))

  (eval [v]
    (traverse v eval)))

(defn define-sum-type [asts]

  (for [ast (sm/when (some asts (partial instance? ast/call-ast)))
        :when (= (.call-target ast) 'comp*)
        :let [[arg & args] (.args ast)
              args (either (for [args-list (first args)
                                 :when (instance? ast/call-ast args-list)]
                             (.args args-list))
                           empty-list)]
        :when (instance? rdr/tagged-symbol arg)
        type-map (lookup-sym arg)
        type-maps (traverse args (fn [arg]
                                   (comp (lookup-sym arg)
                                         (abort-interp "Could not find type definition for"
                                                (str "'" arg "'") "at"
                                                (ast-location-str arg)))))]
    (comp* type-map type-maps)))

(defn define-enum-type [asts]

  (for [ast (sm/when (some asts (partial instance? ast/call-ast)))
        :when (= (.call-target ast) 'enum)
        type-maps (traverse (.args ast) (fn [arg]
                                          ;; TODO
                                          ;; (and (= 1 (count type-map))
                                          ;;      (flat-map (first (seq type-map))
                                          ;;                (fn [[type-num field-set]]
                                          ;;                  (and (empty? field-set)
                                          ;;                       (< TypeCount type-num)))))
                                          (map (comp (lookup-sym arg)
                                                     (abort-interp "Could not find type definition for"
                                                                   (str "'" arg "'") "at"
                                                                   (ast-location-str arg)))
                                               type-mapping)))]
    (TypeMap (comp* {} (seq type-maps)))))

(extend-type ast/string-ast
  Evaluator
  (eval [x]
    (wrap sm/zero-sm (.string x))))

(extend-type ast/integer-ast
  Evaluator
  (eval [x]
    (wrap sm/zero-sm (.int x))))

(extend-type ast/quoted-ast
    Evaluator
    (eval-def [x]
      (eval x))

    (eval [x]
      (sm/state-maybe (untag (.q-val x)))))

(defn definition-value [asts]
  (comp (define-sum-type asts)
        (define-enum-type asts)
        (flat-map (eval asts)
                  (fn [values]
                    (sm/when (last values))))))

(extend-type ast/definition-ast
  Evaluator
  (eval [x]
    (let [sym (.sym x)]
      (comp (for [val (-> (.value-exprs x)
                          (filter (fn [ast]
                                    (or (instance? ast/CodeAST ast)
                                        (instance? rdr/tagged-symbol ast))))
                          (remove (partial instance? ast/inline-ast))
                          definition-value)
                  _ (bind sym val)]
              '_)
            (abort-interp "Could not evaluate definition for" (str "'" sym "'") "at:"
                          (ast-location-str x) "\n")))))

(def FnBodyAST (comp CoreTypes
                     ast/CodeAST
                     rdr/tagged-symbol
                     Thunk
                     ReifiedValue
                     TypeConstructor
                     ast/reify-ast
                     ast/integer-ast
                     ast/string-ast
                     ast/fn-ast))

(defn find-fn-ast-arity [ast args]
  (let [num-args (count args)]
    (reduce (.arities ast) nothing
            (fn [found arity]
              (or (and (= num-args (-> arity .params .fixed count))
                       (= nothing (-> arity .params .variadic))
                       (maybe arity))
                  found
                  (and (-> arity .params .variadic)
                       (<= (-> arity .params .fixed count) num-args)
                       (maybe arity)))))))

(extend-type ast/fn-ast
  Evaluator
  (eval [x]
    (for [new-arities (eval-def (.arities x))
          curr-file (sm/get-val .file-name)
          curr-state (sm/update-state identity)]
      (let [fn-sym (either (.fn-sym x)
                           (rdr/tag 'anon))
            new-fn-sym (or (.ns fn-sym)
                           (maybe (.ns fn-sym (maybe curr-file))))]
        (-> x
            (.arities new-arities)
            (.fn-sym new-fn-sym)
            (Thunk curr-state)))))

  (eval-def [x]
    (for [new-arities (eval-def (.arities x))
          curr-state (sm/update-state identity)]
      (-> x
          (.arities new-arities)
          (Thunk curr-state))))

  (apply-fn [x args]
    (either (map (find-fn-ast-arity x args)
                 (fn [arity]
                   (let [body (filter (.body arity) (partial instance? FnBodyAST))]
                     (either (map (empty? body)
                                  (fn [_]
                                    (abort-interp "Invalid function body at" (ast-location-str x))))
                             (comp (for [syms (get-syms)
                                         curr-file (sm/get-val .file-name)
                                         _ (comp (for [ns-sym (sm/when (for [fn-sym (.fn-sym x)
                                                                             :when (instance? rdr/tagged-symbol fn-sym)
                                                                             ns (.ns fn-sym)]
                                                                         ns))
                                                       new-syms (sm/get-in-val [.ns curr-file .imports ns-sym])
                                                       _ (set-syms new-syms)]
                                                   '_)
                                                 (sm/state-maybe '_))
                                         _ (bind (.params arity) args)
                                         result (map (eval body) (fn [results]
                                                                   (reduce results '_ (fn [_ x] x))))
                                         result (either (map (instance? ast/fn-ast result) eval-def)
                                                        (sm/state-maybe result))
                                         _ (set-syms syms)]
                                     result)
                                   (abort-interp "Could not evaluate function"
                                                 (str "'" (either (.fn-sym x) "<anon>") "'")
                                                 "at" (ast-location-str (.fn-sym x))))))))
            (abort-interp "No arity found for" (str "'" (either (.fn-sym x) "<anon>") "'") "with"
                          (count args) "arguments."))))

(extend-type ast/fn-arity-ast
  Evaluator
  (eval-def [x]
    (for [syms (get-syms)
          new-params (uniqueify (.params x))
          new-body (eval-def (.body x))
          _ (set-syms syms)]
      (-> x
          (.params new-params)
          (.body new-body)))))

(extend-type ast/prototype-ast
  Evaluator
  (eval [prototype]
    (let [proto-name (.fn-name prototype)]
      (either (and (flat-map (instance? rdr/tagged-symbol proto-name)
                             .ns)
                   (maybe (abort-interp "The protcol function name" (str "'" proto-name "'")
                                        "is invalid because it has the prefix"
                                        (str "'" (-> proto-name .ns extract) "/'")
                                        "at" (ast-location-str proto-name))))
              (let [params (.params prototype)]
                (comp (for [disp (lookup-sym proto-name)
                            :when-not (instance? ProtoDispatcher disp)
                            _ (abort-interp "Attempt to redefine" (str "'" proto-name "'")
                                            "as a protocol function at" (ast-location-str prototype)
                                            "failed.")]
                        '_)
                      (flat-map (sm/get-val .file-name)
                                (fn [curr-file-name]
                                  (comp (lookup-sym proto-name)
                                        (bind proto-name
                                              (ProtoDispatcher
                                               proto-name curr-file-name
                                               (either (map (first (.default-body prototype))
                                                            (fn [_]
                                                              {0 (ast/fn-ast (maybe proto-name)
                                                                             [(ast/fn-arity-ast
                                                                               proto-name "" params ""
                                                                               (.default-body prototype)
                                                                               [] c/top-type)])}))
                                                       {})
                                               empty-state)))))))))))

(extend-type ast/protocol-ast
  Evaluator
  (eval [x]
    (comp (flat-map (lookup-sym (.protocol-sym x))
                    (fn [_]
                      (abort-interp "Trying to redefine a protocol named"
                                    (str "'" (.protocol-sym x) "'"))))
          (traverse (.prototypes x) eval))))

(defn reify-impls [impls type-num location]
  (assert (instance? HashMap impls))

  (traverse (for [[protocol proto-impls] (seq impls)
                  [fn-sym impl-arities] (seq proto-impls)
                  arity impl-arities]
              [fn-sym arity])
            (fn [[fn-sym arity]]
              (comp (map (eval-def arity)
                         (fn [new-arity] 
                           {fn-sym (ast/fn-ast (maybe fn-sym) [new-arity])}))
                    (abort-interp "Could not reify an implementation of"
                                  (str "'" fn-sym "'") "at" location)))))

(extend-type ast/reify-ast
  Evaluator
  (eval-def [x]
    (eval x))

  (eval [x]
    (let [loc (ast-location-str x)
          name (str "reified at: " loc)]
      (for [type-num (sm/get-val .type-count)
            _ (sm/set-val .type-count (inc type-num))
            impls (reify-impls (.impls x) type-num loc)
            curr-state (sm/update-state identity)]
        (ReifiedValue (maybe name) type-num [] []
                      (comp* {"" {'=* (fn [x y]
                                        (and (=* (get-type x) (get-type y))
                                             (maybe x)))}}
                             impls)
                      curr-state)))))

(defn find-fn-arity [f n]
  (inline C Maybe "
   return((Value *)maybe((List *)0, (Value *)0, (Value *)findFnArity(f_0, ((Integer *)n_1)->numVal)));
"))

;; (extend-type FnArity
;;   Evaluator
;;   (param-constraints [f]
;;     (inline C Maybe "
;;    return((Value *)maybe((List *)0, (Value *)0, ((FnArity *)f_0)->paramConstraints));
;; ")))

(extend-type ast/call-ast
  Evaluator
  (eval [x]
    (for [call-depth (sm/get-val .call-depth)
          _ (either (map (< call-depth *max-call-depth*) sm/state-maybe)
                    (abort-interp "Recursion limit exceeded at" (ast-location-str x)))
          _ (sm/set-val .call-depth (inc call-depth))
          target (eval (.call-target x))
          args (eval (.args x))
          r (apply-fn target args)
          _ (sm/set-val .call-depth call-depth)]
      r))

  (eval-def [ast]
    (for [target (eval-def (.call-target ast))
          args (eval-def (.args ast))]
      (ast/call-ast target args))))

;; _ (debug 'target (type-name target) target)
;; arity (find-arity target args)
;; _ (sm/when (for [constraints (or (param-constraints arity)
;;                                  ;; TODO: only a temp thing
;;                                  (maybe c/top-type))
;;                  :let [_ (print-err 'args args)
;;                        _ (print-err 'constraints constraints)]
;;                  _ (c/compose-constraints (ast/file-name (.call-target ast))
;;                                           (ast/line-number (.call-target ast))
;;                                           args constraints)]
;;              '_))

(extend-type ast/either-ast
  Evaluator
  (eval-def [x]
    (for [new-clause (eval-def (.clause x))
          new-alt (eval-def (.alt x))]
      (ast/either-ast new-clause new-alt)))

  (eval [x]
    (sm/new-sm (fn [s]
                 (flat-map ((eval (.clause x)) s)
                           (fn [v-s]
                             (let [[v?] v-s]
                               (or (and (instance? Maybe v?)
                                        (or (map v? (fn [v] [v s]))
                                            ((eval (.alt x)) s)))
                                   (do
                                     (print-err "Invalid type of value at " (ast-location-str (.clause x))
                                                ". Needed 'Maybe' got " (str "'" (type-name v?) "'") ".")
                                     nothing)))))))))

(extend-type ast/and-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.clauses x))
         (partial .clauses x)))

  (eval [x]
    (sm/new-sm (fn [s]
                 (let [[clause & clauses] (.clauses x)]
                   (reduce clauses ((eval clause) s)
                           (fn [evalled clause]
                             (flat-map evalled (fn [[do-next? s]]
                                                 (or (and do-next?
                                                          ((eval clause) s))
                                                     (maybe [nothing s])))))))))))

(extend-type ast/or-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.clauses x))
         (partial .clauses x)))

  (eval [x]
    (sm/new-sm (fn [s]
                 (let [[clause & clauses] (.clauses x)]
                   (reduce clauses ((eval clause) s)
                           (fn [evalled clause]
                             (flat-map evalled (fn [v-s]
                                                 (let [[v] v-s]
                                                   (or (and v (maybe v-s))
                                                       ((eval clause) s))))))))))))

(extend-type ast/params-ast
  Evaluator
  (uniqueify [x]
    ;; replace arguments with unique symbols
    (for [new-fixed (traverse (.fixed x) uniqueify)
          new-variadic (comp (flat-map (sm/when (.variadic x))
                                       (fn [arg]
                                         (map (uniqueify arg) maybe)))
                             (sm/state-maybe nothing))]
      (ast/params-ast new-fixed new-variadic)))

  (bind [x vs]
    (let [vs (seq vs)]
      (either (and (instance? Sequence vs)
                   (or (<= (count (.fixed x)) (count vs))
                       (do
                         (print-err "Not enough values in sequence to destructure")
                         (maybe (zero sm/state-maybe))))
                   (maybe (for [ys (traverse (zip-lists (seq (.fixed x)) vs)
                                             (fn [[target v]]
                                               (bind target v)))
                                _ (either (map (.variadic x)
                                               (fn [tail]
                                                 (bind tail (drop vs (count (.fixed x))))))
                                          (sm/state-maybe '_))]
                            ys)))
              (abort-interp "Attempted to destructure a value that was not a List or a Vector")))))

(extend-type ast/let-ast
  Evaluator
  (eval-def [x]
    (for [syms (get-syms)
          new-bindings (eval-def (.bindings x))
          new-body (eval-def (.body x))
          _ (set-syms syms)]
      (ast/let-ast new-bindings new-body)))

  (eval [x]
    (for [curr-state (sm/update-state identity)
          results (eval (comp (.bindings x) (.body x)))
          _ (sm/update-state (fn [_] curr-state))
          result (sm/when (last results))]
      result)))

(extend-type ast/binding-ast
  Evaluator
  (eval-def [x]
    (for [v (eval-def (.val x))
          new-binding (uniqueify (.binding x))
          _ (either (map (instance? fn-thing v)
                         (fn [v]
                           (bind new-binding v)))
                    (sm/state-maybe '_))]
      (ast/binding-ast new-binding v)))

  (eval [x]
    (flat-map (eval (.val x))
              (partial bind (.binding x)))))

(defn set-impls [impls location type-num]
  (assert (instance? HashMap impls))

  (traverse (for [[protocol proto-impls] (seq impls)
                  [fn-sym impl-arities] (seq proto-impls)
                  arity impl-arities]
              [fn-sym arity])
            (fn [[fn-sym arity]]
              (comp (flat-map (get-impl fn-sym type-num)
                              (fn [_]
                                (abort-interp "An implementation of" (str "'" fn-sym "'") "is already defined."
                                              "Redefiniion at" location)))
                    (flat-map (eval-def arity)
                              (fn [new-arity] 
                                (set-proto-impl fn-sym type-num
                                                (ast/fn-ast (maybe fn-sym) [new-arity]))))
                    (abort-interp "Could not reify an implementation of"
                                  (str "'" fn-sym "'") "at" location)))))

(extend-type ast/extend-ast
  Evaluator
  (eval [x]
    (flat-map (comp (lookup-sym (.type x))
                    (abort-interp "Could not extend type" (str "'" (.type x) "'") "at"
                                  (ast-location-str x)))
              (fn [type]
                (traverse (keys (type-mapping type))
                          (partial set-impls (.impls x) (ast-location-str x)))))))

(defn create-constructor [sym fields const-type type-num]
  (for [curr-state (sm/update-state identity)
        _ (set-proto-impl (rdr/tag 'type-name) const-type
                          (fn [_]
                            (str "*" sym " constructor*")))
        _ (set-proto-impl (rdr/tag 'invoke) const-type
                          (fn [_ & field-values]
                            (ReifiedValue (maybe sym) type-num (vec field-values) fields {} curr-state)))
        _ (set-proto-impl (rdr/tag 'apply) const-type
                          (fn [_ field-values-list]
                            (ReifiedValue (maybe sym) type-num (vec field-values-list) fields {} curr-state)))
        _ (set-proto-impl (rdr/tag 'instance?) const-type
                          (fn [constructor v]
                            (and (= type-num (get-type v))
                                 (maybe v))))]
    (TypeConstructor sym const-type type-num fields
                     {type-num (set fields)} curr-state)))

(defn set-type-impls [x type-num]
  (let [sym (.sym x)
        field-indices (reduce (zip-lists (seq (-> x .fields .fixed))
                                         (range (count (.fields x))))
                              {} (fn [m [field-name index]]
                                   (assoc m (rdr/tag (symbol (str "." field-name))) index)))]
    (for [_ (traverse (seq field-indices)
                      (fn [[getter-sym field-idx]]
                        (for [_ (comp (lookup-sym getter-sym)
                                      (bind getter-sym (ProtoDispatcher getter-sym "" {} empty-state)))
                              _ (set-proto-impl getter-sym type-num (fn
                                                                      ([x]
                                                                       (assert (instance? ReifiedValue x))
                                                                       (-> x
                                                                           (type-args)
                                                                           (nth field-idx)
                                                                           (extract)))
                                                                      ([x new-field]
                                                                       (assert (instance? ReifiedValue x))
                                                                       (set-fields x (-> x
                                                                                         (type-args)
                                                                                         (store field-idx new-field)
                                                                                         (extract))))))]
                          '_)))
          _ (set-proto-impl (rdr/tag 'get) type-num
                            (fn [v field]
                              (assert (instance? ReifiedValue v))
                              (for [disp (instance? ProtoDispatcher field)
                                    index (get field-indices (.prototype-name disp))
                                    field (get (type-args v) index)]
                                field)))
          _ (set-proto-impl (rdr/tag 'assoc) type-num
                            (fn [v field new-field-value]
                              (assert (instance? ReifiedValue v))
                              (either (for [disp (instance? ProtoDispatcher field)
                                            index (get field-indices (.prototype-name disp))
                                            new-fields (store (type-args v) index new-field-value)]
                                        (.fields v new-fields))
                                      v)))
          _ (-> (.impls x)
                (remove (partial instance? c/Constraints))
                (traverse (fn [impls]
                            (set-impls impls (ast-location-str x) type-num))))
          _ (set-proto-impl (rdr/tag 'get-type) type-num (fn [_]
                                                           type-num))
          _ (set-proto-impl (rdr/tag 'type-name) type-num (fn [_]
                                                            (str sym)))
          _ (set-proto-impl (rdr/tag 'type-args) type-num type-args)]
      '_)))

(extend-type ast/type-ast
  Evaluator
  (eval [x]
    (let [sym (.sym x)]
      (either (for [_ (and (instance? rdr/tagged-symbol sym)
                           (-> sym .ns))]
                (abort-interp "A new type may not be defined with a namespace qualified symbol."
                       (str "'" sym "' is invalid at" (ast-location-str x))))
              (for [type-num (sm/get-val .type-count)
                    :let [const-type (inc type-num)]
                    _ (sm/set-val .type-count (inc const-type))
                    _ (set-type-impls x type-num)
                    const (create-constructor sym (-> x .fields .fixed) const-type type-num)
                    _ (bind sym const)]
                '_)))))

(extend-type ast/main-ast
  Evaluator
  (eval [x]
    (for [cmd-line (sm/get-val .command-line)
          curr-syms (get-syms)
          _ (bind (.params x) [cmd-line])
          result (eval (.body x))
          _ (set-syms curr-syms)]
      result)))

(extend-type Symbol
  Evaluator
  (bind [sym v]
    (bind (rdr/tag sym) v)))

(extend-type rdr/tagged-symbol
  Evaluator
  (uniqueify [x]
    (either (and (.ns x)
                 (maybe (abort-interp "May not use a namespace-qualified symbol at"
                               (ast-location-str x))))
            (let [new-sym (rdr/tag (gensym (str x "_")))]
              (for [_ (bind x new-sym)]
                new-sym))))

  (lookup-sym [x]
    (for [curr-file (sm/get-val .file-name)
          r (either (map (.ns x)
                         (fn [ns-sym]
                           (sm/get-in-val [.ns curr-file .imports (rdr/tag ns-sym) (rdr/tag (.base x))])))
                    (comp (sm/get-in-val [.ns curr-file .syms x ;; .value
                                          ])
                          (sm/get-in-val [.ns "" .syms x ;; .value
                                          ])))]
      r))

  (eval-def [x]
    (comp (lookup-sym x)
          (sm/state-maybe x)))

  (untag [x]
    (either (map (.ns x)
                 (fn [ns]
                   (symbol (str ns "/" (.base x)))))
            (.base x)))

  (eval [x]
    (comp (lookup-sym x)
          (abort-interp "There is no value bound to" (str "'" x "' at")
                        (ast-location-str x))))

  (bind [x v]
    (either (and (.ns x)
                 (do
                   (print-err "A value can not be bound to a namespace-qualified symbol. At"
                              (str "'" (ast/file-name x) "',") (ast/line-number x))
                   (maybe (zero sm/state-maybe))))
            (flat-map (sm/get-val .file-name)
                      (fn [ns-path]
                        (let [ns-path (either (for [dot? (first (str x))
                                                    _ (= dot? ".")]
                                                "")
                                              ns-path)]
                          (sm/assoc-in-val [.ns ns-path .syms x] v)))))))

(extend-type Fn
  Evaluator
  (apply-fn [f args]
    (sm/state-maybe (apply f (seq args)))))

(extend-type ast/block-comment-ast
  Evaluator
  (eval [x]
    (sm/state-maybe "")))

(extend-type ast/add-ns-ast
  Evaluator
  (eval [x]
    (for [curr-file (sm/get-val .file-name)
          mod-syms (eval (.mod x))
          _ (sm/assoc-in-val [.ns curr-file .imports (.ns-sym x)] mod-syms)
          _ (sm/set-val .file-name curr-file)]
      '_)))

(extend-type ast/declaration-ast
  Evaluator
  (eval [x]
    (sm/state-maybe '_)))
