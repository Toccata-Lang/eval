
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e7a489b"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "ba18227"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "ecde30b"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "7690cd3"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "c89ab00"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "4893cbf"))


(def parse (rd/parser (grmr/none-or-more
                       (grmr/any rdr/read-def
                                 rdr/read-defn
                                 rdr/read-defprotocol
                                 rdr/read-main
                                 rdr/read-extend-type
                                 rdr/read-deftype
                                 rdr/read-block-comment
                                 rdr/read-add-ns
                                 rdr/read-expr))))

;; useful for debugging
(defn debug [& args]
  (sm/new-sm (fn [s]
               (apply print-err args)
               (maybe ['_ s]))))


(deftype EvalNamespace [imports syms impls])

(deftype EvalState [ns types type-nums core-protocols file-name]
  Stringable
  (string-list [_] (list "<EvalState>")))

(defn get-syms []
  (flat-map (sm/get-val .file-name)
            (fn [ns-path]
              (sm/get-in-val [.ns ns-path .syms]))))


(defn set-syms [syms]
  (flat-map (sm/get-val .file-name)
            (fn [ns-path]
              (sm/assoc-in-val [.ns ns-path .syms] syms))))

(defprotocol Evaluator
  (traverse [coll f]
    (assert-result x (instance? sm/new-sm x)))

  (untag [s]
    s)

  (bind [_ _]
    (assert-result r (instance? sm/state-maybe r)))

  (bind-fields [_]
    (sm/state-maybe '_))

  (lookup-sym [s]
    (assert-result r (instance? sm/state-maybe r)))

  (eval* [x]
    (assert-result r (instance? sm/state-maybe r))
    (sm/new-sm (fn [s]
                 (print-err "Could not find implementation of 'eval*' for" (str "''" (type-name x) "'"))
                 nothing)))

  (eval-def [x]
    (assert-result r (instance? sm/state-maybe r)))

  (record-defintion [v sym]
    (assert (instance? Symbol sym))

    (flat-map (eval* v)
              (partial bind sym)))

  (new-protocol [_]
    (assert-result r (instance? sm/state-maybe r)))

  (get-protocol [_]
    (assert-result r (instance? sm/state-maybe r)))

  (set-prototype [sym fn-sym params proto]
    (assert-result r (instance? sm/state-maybe r)))

  (dispatcher-path [_]
    (assert-result r (instance? String r))
    "")

  (get-impl [sym num-args type-num]
    (assert-result r (instance? sm/state-maybe r)))

  (set-impl [sym num-args type-num impl]
    (assert-result r (instance? sm/state-maybe r)))

  (apply-fn [f args]
    (assert-result r (instance? sm/state-maybe r))
    (sm/state-maybe (apply* f (seq args)))))

(defn eval [ast state]
  (assert (instance? EvalState state))

  ((eval* ast) state))

(deftype ReifiedValue [type-sym type-num fields field-names]
  (assert (instance? Maybe type-sym))
  (assert (instance? Integer type-num))
  (assert (instance? Vector fields))
  (assert (instance? params-ast fields))

  Stringable
  (string-list [_]
    (list "<ReifiedValue '" (str (either type-sym "")) "' " (str type-num) ">"))

  Evaluator
  (eval* [x]
    (sm/state-maybe x))

  (bind-fields [_]
    (bind field-names fields))

  (apply-fn [disp-arg args]
    (let [num-args (inc (count args))]
      (flat-map (comp (get-impl 'invoke num-args type-num)
                      (get-impl 'invoke num-args 0))
                (fn [impl]
                  (apply-fn impl (cons disp-arg (seq args))))))))

(extend-type List
  Evaluator
  (traverse [asts f]
    (-> asts
        (remove (partial instance? ast/block-comment-ast))
        reverse
        (reduce (sm/state-maybe empty-list)
                (fn [l ast]
                  (flat-map (f ast)
                            (fn [emitted]
                              (map l (fn [x]
                                       (cons emitted x)))))))))

  (eval-def [v]
    (traverse v eval-def))

  (eval* [v]
    (traverse v eval*)))

(extend-type Vector
  Evaluator
  (traverse [asts f]
    (-> asts
        (remove (partial instance? ast/block-comment-ast))
        reverse
        (reduce (sm/state-maybe empty-vector)
                (fn [v ast]
                  (flat-map (f ast)
                            (fn [emitted]
                              (map v (fn [v]
                                       (conj v emitted)))))))
        (map reverse)))

  (eval-def [v]
    (traverse v eval-def))

  (eval* [v]
    (traverse v eval*)))

(deftype SumType [type-map]
  Stringable
  (string-list [_]
    (list "<SumType " (str type-map) ">"))

  Evaluator
  (record-defintion [_ sym]
    (sm/assoc-in-val [.type-nums sym] type-map)))

(extend-type ast/definition-ast
  Evaluator
  (eval* [x]
    (let [sym (untag (.sym x))]
      (comp (-> (.value-exprs x)
                (filter (fn [ast]
                          (or (instance? ast/CodeAST ast)
                              (instance? rdr/tagged-symbol ast)
                              (instance? ast/fn-ast ast))))
                (remove (partial instance? ast/inline-ast))
                eval-def
                (flat-map (fn [exprs]
                            (either (and (empty? exprs)
                                         (maybe (zero sm/state-maybe)))
                                    (record-defintion (reduce exprs '_ (fn [_ x] x)) sym)))))
            (lookup-sym sym)
            (sm/new-sm (fn [s]
                         (print-err (str "'" sym) sym)
                         ;; (print-err "Could not evaluate definition for " (str "'" sym "'") "at:"
                         ;;            (ast/file-name x) (ast/line-number x))
                         (maybe ['_ s])))))))

(defn ast-location-str [x]
  (str (ast/file-name x) ": "
       (ast/line-number x)))

;; TODO: investigate infinite and mutual recursion
(extend-type ast/fn-ast
  Evaluator
  (eval-def [x]
    ;; TODO: this is a stop-gap. It should allow some arities to be ast's and some to be inline
    (either (map (and (some (flat-map (.arities x) .body)
                            (partial instance? ast/inline-ast))
                      (or (.fn-sym x)
                          (maybe "")))
                 (fn [fn-sym]
                   (lookup-sym fn-sym)
                   ;; (comp (sm/get-in-val [.syms (untag fn-sym)]
                   ;;       (sm/new-sm (fn [s]
                   ;;                    (print-err "Could not define function" (str "'" fn-sym "'") "at:"
                   ;;                               (ast/file-name x) (ast/line-number x))
                   ;;                    nothing)))
                   ))
            (map (eval-def (.arities x))
                 (partial .arities x))))

  (apply-fn [x args]
    (let [num-args (count args)
          arity (reduce (.arities x) nothing
                        (fn [found arity]
                          (or (and (= num-args (-> arity .params .fixed count))
                                   (= nothing (-> arity .params .variadic))
                                   (maybe arity))
                              found
                              (and (-> arity .params .variadic)
                                   (<= (-> arity .params .fixed count) num-args)
                                   (maybe arity)))))]
      (for [arity (sm/when arity)
            syms (get-syms)
            _ (bind (.params arity) args)
            :let [body (.body arity)
                  assertions (filter body (partial instance? ast/assert-ast))
                  result-asserts (filter body (partial instance? ast/result-ast))
                  body (filter body (partial instance? ast/CodeAST))]
            :when-not (empty? body)
            results (eval* body)
            _ (set-syms syms)]
        (reduce results '_ (fn [_ x] x)))))

  (eval* [x]
    (sm/state-maybe x)))

(extend-type ast/fn-arity-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.body x))
         (partial .body x))))

(extend-type ast/either-ast
  Evaluator
  (eval-def [x]
    (for [new-clause (eval-def (.clause x))
          new-alt (eval-def (.alt x))]
      (ast/either-ast new-clause new-alt)))

  (eval* [x]
    (sm/new-sm (fn [s]
                 (flat-map ((eval* (.clause x)) s)
                           (fn [v-s]
                             (let [[v?] v-s]
                               (or (map v? (fn [v] [v s]))
                                   ((eval* (.alt x)) s)))))))))

(deftype ProtoDispatcher [prototype-name path]
  (assert (instance? Symbol prototype-name))

  Stringable
  (string-list [_]
    (list "<ProtoDispatcher " (str prototype-name) " " (str "'" path "'") ">"))

  Evaluator
  (dispatcher-path [_]
    path)

  (eval* [x]
    (sm/state-maybe x))

  (apply-fn [_ args]
    (let [num-args (count args)
          [disp-arg & args] args
          disp-type (either (map (instance? ReifiedValue disp-arg) .type-num)
                            (get-type disp-arg))]
      (for [impl (comp (sm/get-in-val [.ns path .impls prototype-name num-args disp-type])
                       (sm/get-in-val [.ns path .impls prototype-name num-args 0]))
            syms (get-syms)
            _ (bind-fields disp-arg)
            r (apply-fn impl (cons disp-arg args))
            _ (set-syms syms)]
        r))))

(defn default-impl [fn-sym]
  (fn [disp-arg & args]
    (let [type-str (either
                    (and (instance? ReifiedValue disp-arg)
                         (or (.type-sym disp-arg)
                             (maybe (.type-num disp-arg))))
                    (type-name disp-arg))]
      (print-err "Could not find implementation of"
                 (str "'" fn-sym "'") "with"
                 (inc (count args))
                 "arguments for type"
                 (str type-str ".")))
    (abort)))

(extend-type ast/protocol-ast
  Evaluator
  (eval* [x]
    (let [proto-sym (.protocol-sym x)]
      (for [_ (new-protocol proto-sym)
            curr-file-name (sm/get-val .file-name)
            _ (traverse (.prototypes x)
                        (fn [prototype]
                          (assert (instance? ast/prototype-ast prototype))

                          (let [fn-sym (untag (.fn-name prototype))
                                params (.params prototype)
                                num-args (count params)]
                            (comp (for [_ (get-impl fn-sym num-args 0)]
                                    (print-err "Attempt to redefine protocol function" (str "'" fn-sym "'")
                                               "at" (ast-location-str x)
                                               "failed. Kept existing definition."))
                                  (for [_ (set-prototype proto-sym fn-sym params prototype)
                                        _ (comp (lookup-sym fn-sym)
                                                (bind fn-sym (ProtoDispatcher fn-sym curr-file-name)))
                                        _ (either (-> (.default-body prototype)
                                                      (filter (partial instance? ast/CodeAST))
                                                      (empty?)
                                                      (map (fn [_]
                                                             (set-impl fn-sym num-args 0
                                                                       (default-impl (untag fn-sym))))))
                                                  (flat-map (eval-def (ast/fn-ast
                                                                       (maybe fn-sym)
                                                                       [(ast/fn-arity-ast fn-sym "" params ""
                                                                                          (.default-body prototype))]))
                                                            (partial set-impl fn-sym num-args 0)))]
                                    '_)))))]
        '_))))

(defn wrap-arity [fn-arity]
  (inline C "
   FnArity *arity = (FnArity *)fn_arity_0;
   Function *f = malloc_function(1);
   f->arityCount = 1;
   f->arities[0] = arity;
   return((Value *)f);"))

;; _ (comp (get-protocol protocol)
;;                             (sm/new-sm (fn [s]
;;                                          (print-err "Invalid protocol" (str "'" protocol "'")
;;                                                     "at" location)
;;                                          nothing)))

(defn reify-impls [impls type-num location]
  (traverse (seq impls)
            (fn [[protocol proto-impls]]
              (traverse (for [[fn-sym arities] (seq proto-impls)
                              arity arities]
                          [fn-sym arity])
                        (fn [[fn-sym arity]]
                          (let [num-args (count (.params arity))]
                            (comp (get-impl fn-sym num-args type-num)
                                  (for [impl (either (and (some (.body arity)
                                                                (partial instance? ast/inline-ast))
                                                          (maybe
                                                           (map (sm/get-in-val [.core-protocols protocol
                                                                                (untag fn-sym) num-args
                                                                                type-num])
                                                                wrap-arity)))
                                                     (for [new-arity (eval-def arity)]
                                                       (ast/fn-ast (maybe fn-sym) [new-arity])))
                                        _ (comp (for [_ (get-impl fn-sym num-args 0)
                                                      _ (set-impl fn-sym num-args type-num impl)]
                                                  '_)
                                                (for [disp-fn (eval* fn-sym)
                                                      curr-file-name (sm/get-val .file-name)
                                                      _ (bind fn-sym (ProtoDispatcher fn-sym curr-file-name))
                                                      _ (set-impl fn-sym num-args 0 disp-fn)
                                                      _ (set-impl fn-sym num-args type-num impl)]
                                                  '_))]
                                    '_))))))))

(extend-type ast/reify-ast
  Evaluator
  (eval-def [x]
    (for [type-nums (sm/get-val .type-nums)
          :let [type-num (count type-nums)]
          _ (sm/assoc-in-val [.type-nums type-num] type-num)
          _ (reify-impls (.impls x) type-num (ast-location-str x))]
      (ReifiedValue nothing type-num [] []))))

(extend-type ast/call-ast
  Evaluator
  (record-defintion [v sym]
    (flat-map (eval* v)
              (partial bind sym)))

  (eval-def [ast]
    (let [target (.call-target ast)]
      (comp (for [_ (sm/when (= target 'comp*))
                  :let [[arg & args] (.args ast)
                        args (either (for [args-list (first args)
                                           :when (instance? ast/call-ast args-list)]
                                       (.args args-list))
                                     empty-list)]
                  type-map (sm/get-in-val [.type-nums arg])
                  type-maps (traverse args (fn [arg]
                                             (comp (sm/get-in-val [.type-nums arg])
                                                   (sm/new-sm (fn [s]
                                                                (print-err "Could not find type definition for"
                                                                           (str "'" arg "'") "at"
                                                                           (ast-location-str arg))
                                                                nothing)))))]
              (SumType (comp* type-map type-maps)))
            (for [target (eval-def (.call-target ast))
                  args (eval-def (.args ast))]
              (ast/call-ast target args)))))

  (eval* [x]
    (for [target (eval* (.call-target x))
          args (eval* (.args x))
          r (apply-fn target args)]
      r)))

(extend-type ast/and-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.clauses x))
         (partial .clauses x)))

  (eval* [x]
    (sm/new-sm (fn [s]
                 (let [[clause & clauses] (.clauses x)]
                   (reduce clauses ((eval* clause) s)
                           (fn [evalled clause]
                             (flat-map evalled (fn [[do-next? s]]
                                                 (or (and do-next?
                                                          ((eval* clause) s))
                                                     (maybe [nothing s])))))))))))

(extend-type ast/or-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.clauses x))
         (partial .clauses x)))

  (eval* [x]
    (sm/new-sm (fn [s]
                 (let [[clause & clauses] (.clauses x)]
                   (reduce clauses ((eval* clause) s)
                           (fn [evalled clause]
                             (flat-map evalled (fn [v-s]
                                                 (let [[v] v-s]
                                                   (or (and v (maybe v-s))
                                                       ((eval* clause) s))))))))))))

(extend-type ast/assert-ast
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval* [assertion]
    ;; TODO: this needs to be completed
    (sm/state-maybe assertion)))

(extend-type ast/result-ast
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval* [assertion]
    ;; TODO: this needs to be completed
    (sm/state-maybe assertion))
  )

(extend-type ast/params-ast
  Evaluator
  (bind [x vs]
    (either (and (instance? Sequence vs)
                 (or (<= (count (.fixed x)) (count vs))
                     (do
                       (print-err "Not enough values in sequence to destructure")
                       (maybe (zero sm/state-maybe))))
                 (maybe (for [ys (traverse (zip-lists (seq (.fixed x)) vs)
                                                (fn [[target v]]
                                                  (bind target v)))
                              _ (either (map (.variadic x)
                                             (fn [tail]
                                               (bind tail (drop (seq vs) (count (.fixed x))))))
                                        (sm/state-maybe '_))]
                          ys)))
            (do
              (print-err "Attempted to destructure a value that was not a List or a Vector")
              (zero sm/state-maybe)))))

(extend-type ast/let-ast
  Evaluator
  (eval-def [x]
    (for [new-bindings (eval-def (.bindings x))
          new-body (eval-def (.body x))]
      (ast/let-ast new-bindings new-body)))

  (eval* [x]
    (for [curr-state (sm/new-sm (fn [s] (maybe [s s])))
          results (eval* (comp (.bindings x) (.body x)))
          _ (sm/new-sm (fn [_] (maybe [curr-state curr-state])))]
      (reduce results '_ (fn [_ x] x)))))

(extend-type ast/binding-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.val x))
         (partial .val x)))

  (eval* [x]
    (flat-map (eval* (.val x))
              (partial bind (.binding x)))))

(extend-type ast/extend-ast
  Evaluator
  (eval* [x]
    (flat-map (comp (sm/get-in-val [.type-nums (.type x)])
                    (sm/new-sm (fn [s]
                                 (print-err "Could not extend type" (str "'" (.type x) "'") "at"
                                            (ast-location-str x))
                                 nothing)))
              (fn [type-map]
                (traverse (keys type-map)
                           (fn [type-num]
                             (comp (reify-impls (.impls x) type-num (ast-location-str x))
                                   (sm/state-maybe '_))))))))

(extend-type ast/type-ast
  Evaluator
  (eval* [x]
    (let [num-fields (count (.fields x))
          sym (untag (.sym x))]
      (for [type-nums (sm/get-val .type-nums)
            :let [type-num (count type-nums)
                  const-type (inc type-num)]
            _ (sm/assoc-in-val [.type-nums] (comp type-nums {(.sym x) {type-num #{}}
                                                             const-type {const-type #{}}}))
            _ (set-impl 'string-list 1 const-type
                        (fn [c]
                          (list (str (either (.type-sym c) (.type-num c))))))
            _ (set-impl 'invoke (inc num-fields) const-type
                        (fn [_ & fields]
                          (ReifiedValue (maybe (.sym x)) type-num (vec fields) (.fields x))))
            _ (set-impl 'instance? 2 const-type
                        (fn [constructor v]
                          (and (= type-num (either (map (instance? ReifiedValue v) .type-num)
                                                   (get-type v)))
                               (maybe v))))
            _ (bind sym (ReifiedValue (-> (str "*" sym " constructor*") symbol maybe)
                                      const-type [] []))
            _ (traverse (remove (.impls x) (partial instance? ast/assert-ast))
                        (fn [impls]
                          (reify-impls impls type-num (ast-location-str x))))]
        '_))))

(extend-type ast/main-ast
  Evaluator
  (eval* [x]
    ;; TODO: bind the arg list
    (eval* (.body x))))

(extend-type ast/quoted-ast
    Evaluator
    (eval-def [x]
      (sm/state-maybe x))

    (eval* [x]
      (sm/state-maybe (untag (.q-val x)))))

(extend-type Integer
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval* [x]
    (sm/state-maybe x)))

(extend-type Symbol
  Evaluator
  (lookup-sym [x]
    (comp (flat-map (sm/get-val .file-name)
                    (fn [ns-path]
                      (sm/get-in-val [.ns ns-path .syms x])))
          (sm/get-in-val [.ns "" .syms x])))

  (bind [sym v]
    (flat-map (sm/get-val .file-name)
              (fn [ns-path]
                (sm/assoc-in-val [.ns ns-path .syms sym] v))))

  (new-protocol [sym]
    (sm/new-sm (fn [s]
                 (either (and (or (get-in s [.ns (.file-name s) .syms sym])
                                  (get-in s [.ns "" .syms sym]))
                              (do
                                (print-err "Trying to redefine a protocol named"
                                           (str "'" sym "'"))
                                (maybe nothing)))
                         (maybe ['_ s])))))

  (get-protocol [sym]
    (sm/new-sm (fn [s]
                 (either (map (or (get-in s [.ns (.file-name s) .syms sym])
                                  (get-in s [.ns "" .syms sym]))
                              (fn [proto]
                                (maybe [proto s])))
                         nothing))))

  (set-prototype [sym fn-sym params proto]
    (flat-map (comp (map (sm/get-in-val [.ns "" .syms sym])
                         (fn [_] ""))
                    (sm/get-val .file-name))
              (fn [curr-file-name]
                (sm/assoc-in-val [.ns curr-file-name .syms sym fn-sym params] proto))))

  (get-impl [sym num-args type-num]
    (flat-map (lookup-sym sym)
              (fn [dispatcher]
                (sm/get-in-val [.ns (dispatcher-path dispatcher) .impls sym num-args type-num]))))

  (set-impl [sym num-args type-num impl]
    (flat-map (comp (map (sm/get-in-val [.ns "" .impls sym num-args])
                         (fn [_] ""))
                    (sm/get-val .file-name))
              (fn [ns-path]
                (sm/assoc-in-val [.ns ns-path .impls sym num-args type-num] impl))))

  (eval* [x]
    (comp (lookup-sym x)
          (sm/new-sm (fn [s]
                       (print-err "There is no value bound to" (str "'" x "'."))
                       ;; TODO: put an abort in here and see what happens
                       nothing))))

  (eval-def [x]
    (comp (lookup-sym x)
          (sm/state-maybe x))))

(extend-type rdr/tagged-symbol
  Evaluator
  (lookup-sym [x]
    (either (map (.ns x)
                 (fn [ns-sym]
                   (for [curr-file (sm/get-val .file-name)
                         r (sm/get-in-val [.ns curr-file .imports (untag ns-sym) (untag (.base x))])]
                     r)))
            (comp (flat-map (sm/get-val .file-name)
                            (fn [ns-path]
                              (sm/get-in-val [.ns ns-path .syms (untag x)])))
                  (sm/get-in-val [.ns "" .syms (untag x)]))))

  (new-protocol [sym]
    (sm/new-sm (fn [s]
                 (either (and (or (get-in s [.ns (.file-name s) .syms sym])
                                  (get-in s [.ns "" .syms sym]))
                              (do
                                (print-err "Trying to redefine a protocol named"
                                           (str "'" sym "'"))
                                (maybe nothing)))
                         (maybe ['_ s])))))

  (get-protocol [sym]
    (sm/new-sm (fn [s]
                 (either (map (or (get-in s [.ns (.file-name s) .syms (untag sym)])
                                  (get-in s [.ns "" .syms (untag sym)]))
                              (fn [proto]
                                (maybe [proto s])))
                         nothing))))

  (set-prototype [sym fn-sym params proto]
    (flat-map (sm/get-val .file-name)
              (fn [curr-file-name]
                (sm/assoc-in-val [.ns curr-file-name .syms (untag (.base sym)) (untag fn-sym) params]
                                 proto))))

  (untag [x]
    (either (map (.ns x)
                 (fn [ns]
                   (symbol (str ns "/" (.base x)))))
            (.base x)))

  (eval-def [x]
    (comp (lookup-sym x)
          (sm/state-maybe (untag x))))

  (bind [x v]
    (either (and (.ns x)
                 (do
                   (print-err "A value can not be bound to a namespace-qualified symbol. At"
                              (str "'" (ast/file-name x) "',") (ast/line-number x))
                   (zero sm/state-maybe)))
            (bind (untag x) v)))

  (get-impl [sym num-args type-num]
    (flat-map (lookup-sym sym)
              (fn [dispatcher]
                (sm/get-in-val [.ns (dispatcher-path dispatcher) .impls (untag (.base sym))
                                num-args type-num]))))

  (set-impl [sym num-args type-num impl]
    (flat-map (lookup-sym sym)
              (fn [dispatcher]
                (sm/assoc-in-val [.ns (dispatcher-path dispatcher) .impls
                                  (untag (.base sym)) num-args type-num]
                                 impl))))

  (eval* [x]
    (comp (lookup-sym x)
          (sm/new-sm (fn [s]
                       (print-err "There is no value bound to" (str "'" x "' at")
                                  (ast-location-str x))
                       nothing)))))

(extend-type Maybe
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval* [x]
    (sm/state-maybe x)))

(extend-type HashMap
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval* [x]
    (sm/state-maybe x)))

(extend-type String
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval* [x]
    (sm/state-maybe x)))

(extend-type Fn
  Evaluator
  (eval* [f]
    (sm/state-maybe f))

  (apply-fn [f args]
    (sm/state-maybe (apply f (seq args)))))


(extend-type ast/block-comment-ast
  Evaluator
  (eval* [x]
    (sm/state-maybe "")))

(extend-type ast/module-ast
  Evaluator
  (eval* [x]
    (let [file (.file-path x)]
      ;; TODO: check to see if module has already been loaded
      (for [asts (sm/when (for [file-in (fio/file-in file)
                                asts (parse {'file-name file
                                             'line-number 1}
                                            (lazy-list file-in))]
                            asts))
            _ (sm/set-val .file-name file)
            _ (sm/assoc-in-val [.ns file] (EvalNamespace {} {} {}))
            _ (eval* asts)]
        file))))

(extend-type ast/add-ns-ast
  Evaluator
  (eval* [x]
    (for [curr-file (sm/get-val .file-name)
          mod-file (eval* (.mod x))
          mod-syms (sm/get-in-val [.ns mod-file .syms])
          _ (sm/assoc-in-val [.ns curr-file .imports (untag (.ns-sym x))] mod-syms)
          _ (sm/set-val .file-name curr-file)]
      '_)))

;; (extend-type ast/git-dep-ast
;;   Evaluator
;;   (eval* [x]
;;     ))

;; (extend-type ast/inline-ast
;;     Evaluator
;;     (eval* [x]
;;       (zero sm/state-maybe)))

;; (extend-type ast/declaration-ast
;;   Evaluator
;;   (eval* [x]
;;     ))
