
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "ba18227"))

(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "ecde30b"))


;; TODO: it's an abomination that this is needed in here
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "4893cbf"))


(deftype EvalState [syms types type-nums protocols implementations core-protocols]
  Stringable
  (string-list [_] (list "<EvalState>")))

(defprotocol Evaluator
  (traverse [coll f]
    (assert-result x (instance? sm/new-sm x)))

  (untag [s]
    s)

  (bind [_ _]
    (assert-result r (instance? sm/state-maybe r)))

  (bind-fields [_]
    (sm/state-maybe '_))

  (eval* [x]
    (assert-result r (instance? sm/state-maybe r))
    (sm/new-sm (fn [s]
                 (print-err "Could not find implementation of 'eval*' for" (str "''" (type-name x) "'"))
                 nothing)))

  (eval-def [x]
    (assert-result r (instance? sm/state-maybe r)))

  (record-defintion [v sym]
    (assert (instance? Symbol sym))

    (flat-map (eval* v)
              (partial sm/assoc-in-val [.syms sym])))

  (apply-fn [f args]
    (assert-result r (instance? sm/state-maybe r))
    (sm/state-maybe (apply* f (seq args)))))

(defn eval [ast state]
  (assert (instance? EvalState state))

  ((eval* ast) state))

(deftype ReifiedValue [type-sym type-num fields field-names]
  (assert (instance? Maybe type-sym))
  (assert (instance? Integer type-num))
  (assert (instance? Vector fields))
  (assert (instance? params-ast fields))

  Stringable
  (string-list [_]
    (list "<ReifiedValue '" (str (either type-sym "")) "' " (str type-num) ">"))

  Evaluator
  (bind-fields [_]
    (bind field-names fields))

  (apply-fn [disp-arg args]
    (let [num-args (inc (count args))]
      (flat-map (comp (sm/get-in-val [.implementations 'invoke num-args type-num])
                      (sm/get-in-val [.implementations 'invoke num-args 0]))
                (fn [impl] 
                  (apply-fn impl (cons disp-arg (seq args))))))))

(extend-type List
  Evaluator
  (traverse [asts f]
    (-> asts
        (remove (partial instance? ast/block-comment-ast))
        reverse
        (reduce (sm/state-maybe empty-list)
                (fn [l ast]
                  (flat-map (f ast)
                            (fn [emitted]
                              (map l (fn [x]
                                       (cons emitted x)))))))))

  (eval-def [v]
    (traverse v eval-def))

  (eval* [v]
    (traverse v eval*)))

(extend-type Vector
  Evaluator
  (traverse [asts f]
    (-> asts
        (remove (partial instance? ast/block-comment-ast))
        reverse
        (reduce (sm/state-maybe empty-vector)
                (fn [v ast]
                  (flat-map (f ast)
                            (fn [emitted]
                              (map v (fn [v]
                                       (conj v emitted)))))))
        (map reverse)))

  (eval-def [v]
    (traverse v eval-def))

  (eval* [v]
    (traverse v eval*)))

(deftype SumType [type-map]
  Stringable
  (string-list [_]
    (list "<SumType " (str type-map) ">"))

  Evaluator
  (record-defintion [_ sym]
    (sm/assoc-in-val [.type-nums sym] type-map)))

(extend-type ast/definition-ast
  Evaluator
  (eval* [x]
    (let [sym (untag (.sym x))]
      (comp (-> (.value-exprs x)
                (filter (fn [ast]
                          (or (instance? ast/CodeAST ast)
                              (instance? rdr/tagged-symbol ast)
                              (instance? ast/fn-ast ast))))
                (remove (partial instance? ast/inline-ast))
                eval-def
                (flat-map (fn [exprs] 
                            (either (and (empty? exprs)
                                         (maybe (zero sm/state-maybe)))
                                    (record-defintion (reduce exprs '_ (fn [_ x] x)) sym)))))
            (sm/get-in-val [.syms sym])
            (sm/new-sm (fn [s]
                         (print-err (str "'" sym) sym)
                         ;; (print-err "Could not evaluate definition for " (str "'" sym "'") "at:"
                         ;;            (ast/file-name x) (ast/line-number x))
                         (maybe ['_ s])))))))

(defn ast-location-str [x]
  (str (ast/file-name x) ": "
       (ast/line-number x)))

(extend-type ast/fn-ast
  Evaluator
  (eval-def [x]
    ;; TODO: this is a stop-gap. It should allow some arities to be ast's and some to be inline
    (either (map (and (some (flat-map (.arities x) .body)
                            (partial instance? ast/inline-ast))
                      (or (.fn-sym x)
                          (maybe "")))
                 (fn [fn-sym]
                   (sm/get-in-val [.syms (untag fn-sym)])
                   ;; (comp (sm/get-in-val [.syms (untag fn-sym)]
                   ;;       (sm/new-sm (fn [s]
                   ;;                    (print-err "Could not define function" (str "'" fn-sym "'") "at:"
                   ;;                               (ast/file-name x) (ast/line-number x))
                   ;;                    nothing)))
                   ))
            (map (eval-def (.arities x))
                 (partial .arities x))))

  (apply-fn [x args]
    (let [num-args (count args)
          arity (reduce (.arities x) nothing
                        (fn [found arity]
                          (or (and (= num-args (-> arity .params .fixed count))
                                   (maybe arity))
                              found
                              (and (-> arity .params .variadic)
                                   (maybe arity)))))]
      (for [arity (sm/when arity)
            syms (sm/get-val .syms)
            _ (bind (.params arity) args)
            :let [body (.body arity)
                  assertions (filter body (partial instance? ast/assert-ast))
                  result-asserts (filter body (partial instance? ast/result-ast))
                  body (filter body (partial instance? ast/CodeAST))]
            :when-not (empty? body)
            results (eval* body)
            _ (sm/set-val .syms syms)]
        (reduce results '_ (fn [_ x] x)))))

  (eval* [x]
    (sm/state-maybe x)))

(extend-type ast/fn-arity-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.body x))
         (partial .body x))))

(extend-type ast/either-ast
  Evaluator
  (eval-def [x]
    (for [new-clause (eval-def (.clause x))
          new-alt (eval-def (.alt x))]
      (ast/either-ast new-clause new-alt)))

  (eval* [x]
    (sm/new-sm (fn [s]
                 (flat-map ((eval* (.clause x)) s)
                           (fn [v-s]
                             (let [[v?] v-s]
                               (or (map v? (fn [v] [v s]))
                                   ((eval* (.alt x)) s)))))))))

(deftype ProtoDispatcher [prototype-name]
  (assert (instance? Symbol prototype-name))
  
  Stringable
  (string-list [_]
    (list "<ProtoDispatcher " (str prototype-name) ">"))

  Evaluator
  (eval* [x]
    (sm/state-maybe x))

  (apply-fn [_ args]
    (let [num-args (count args)
          [disp-arg & args] args
          disp-type (either (map (instance? ReifiedValue disp-arg) .type-num)
                            (get-type disp-arg))]
      (for [impl (comp (sm/get-in-val [.implementations prototype-name num-args disp-type])
                       (sm/get-in-val [.implementations prototype-name num-args 0]))
            syms (sm/get-val .syms)
            _ (bind-fields disp-arg)
            r (apply-fn impl (cons disp-arg args))
            _ (sm/set-val .syms syms)]
        r))))

(extend-type ast/protocol-ast
  Evaluator
  (eval* [x]
    (for [_ (sm/new-sm (fn [s]
                         (either (and (get-in s [.protocols (.protocol-sym x)])
                                      (do
                                        (print-err "Trying to redefine a protocol named"
                                                   (str "'" (.protocol-sym x) "'") "at"
                                                   (ast-location-str x))
                                        (maybe nothing)))
                                 (maybe ['_ s]))))
          _ (traverse (.prototypes x)
                      (fn [prototype]
                        (assert (instance? ast/prototype-ast prototype))

                        (let [fn-sym (untag (.fn-name prototype))
                              params (.params prototype)
                              num-args (count params)]
                          (comp (for [_ (sm/get-in-val [.implementations fn-sym num-args 0])]
                                  (print-err "Attempt to redefine protocol function" (str "'" fn-sym "'")
                                             "at" (ast-location-str x)
                                             "failed. Kept existing definition."))
                                (for [_ (sm/assoc-in-val [.protocols (.protocol-sym x) fn-sym params] prototype)
                                      _ (sm/assoc-in-val [.syms fn-sym] (ProtoDispatcher fn-sym))
                                      _ (either (-> (.default-body prototype)
                                                    (filter (partial instance? ast/CodeAST))
                                                    (empty?)
                                                    (map (fn [_]
                                                           (sm/assoc-in-val
                                                            [.implementations fn-sym num-args 0]
                                                            (fn [disp-arg & args]
                                                              (let [type-str (either
                                                                              (and (instance? ReifiedValue disp-arg)
                                                                                   (or (.type-sym disp-arg)
                                                                                       (maybe (.type-num disp-arg))))
                                                                              (get-type disp-arg))]
                                                                (print-err "Could not find implementation of"
                                                                           (str "'" fn-sym "'") "with"
                                                                           (inc (count args))
                                                                           "arguments for type"
                                                                           (str type-str ".")))
                                                              (abort))))))
                                                (flat-map (eval-def (ast/fn-ast
                                                                     (maybe fn-sym)
                                                                     [(ast/fn-arity-ast fn-sym "" params ""
                                                                                        (.default-body prototype))]))
                                                          (partial sm/assoc-in-val [.implementations fn-sym
                                                                                    num-args 0])))]
                                  '_)))))]
      '_)))

(defn wrap-arity [fn-arity]
  (inline C "
   FnArity *arity = (FnArity *)fn_arity_0;
   Function *f = malloc_function(1);
   f->arityCount = 1;
   f->arities[0] = arity;
   return((Value *)f);"))

(defn reify-impls [impls type-num location]
  (traverse (seq impls)
            (fn [[protocol proto-impls]]
              (for [_ (comp (sm/get-in-val [.protocols protocol])
                            (sm/new-sm (fn [s]
                                         (print-err "Invalid protocol" (str "'" protocol "'")
                                                    "at" location)
                                         nothing)))
                    _ (traverse (for [[fn-sym arities] (seq proto-impls)
                                      arity arities]
                                  [(untag fn-sym) arity])
                                (fn [[fn-sym arity]]
                                  (let [num-args (count (.params arity))]
                                    (comp (sm/get-in-val [.implementations fn-sym num-args type-num])
                                          (for [impl (either (and (some (.body arity)
                                                                        (partial instance? ast/inline-ast))
                                                                  (maybe
                                                                   (map (sm/get-in-val [.core-protocols protocol
                                                                                        fn-sym num-args type-num])
                                                                        wrap-arity)))
                                                             (for [new-arity (eval-def arity)]
                                                               (ast/fn-ast (maybe fn-sym) [new-arity])))
                                                _ (comp (for [_ (sm/get-in-val [.implementations fn-sym num-args 0])
                                                              - (sm/assoc-in-val [.implementations fn-sym
                                                                                  num-args type-num]
                                                                                 impl)]
                                                          '_)
                                                        (for [disp-fn (sm/get-in-val [.syms fn-sym])
                                                              _ (sm/assoc-in-val [.syms fn-sym]
                                                                                 (ProtoDispatcher fn-sym))
                                                              - (sm/assoc-in-val
                                                                 [.implementations fn-sym num-args]
                                                                 {0 disp-fn
                                                                  type-num impl})]
                                                          '_))]
                                            '_)))))]
                '_))))

(extend-type ast/reify-ast
  Evaluator
  (eval-def [x]
    (for [type-nums (sm/get-val .type-nums)
          :let [type-num (count type-nums)]
          _ (sm/assoc-in-val [.type-nums type-num] type-num)
          _ (reify-impls (.impls x) type-num (ast-location-str x))]
      (ReifiedValue nothing type-num [] []))))

(extend-type ast/call-ast
  Evaluator
  (record-defintion [v sym]
    (flat-map (eval* v)
              (partial sm/assoc-in-val [.syms sym])))

  (eval-def [ast]
    (let [target (.call-target ast)]
      (comp (for [_ (sm/when (= target 'comp*))
                  :let [[arg & args] (.args ast)
                        args (either (for [args-list (first args)
                                           :when (instance? ast/call-ast args-list)]
                                       (.args args-list))
                                     empty-list)]
                  type-map (sm/get-in-val [.type-nums arg])
                  type-maps (traverse args (fn [arg]
                                             (comp (sm/get-in-val [.type-nums arg])
                                                   (sm/new-sm (fn [s]
                                                                (print-err "Could not find type definition for"
                                                                           (str "'" arg "'") "at"
                                                                           (ast-location-str arg))
                                                                nothing)))))]
              (SumType (comp* type-map type-maps)))
            (for [target (eval-def (.call-target ast))
                  args (eval-def (.args ast))]
              (ast/call-ast target args)))))

  (eval* [x]
    (for [target (eval* (.call-target x))
          args (eval* (.args x))
          r (apply-fn target args)]
      r)))

(extend-type ast/and-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.clauses x))
         (partial .clauses x)))
  
  (eval* [x]
    (sm/new-sm (fn [s]
                 (let [[clause & clauses] (.clauses x)]
                   (reduce clauses ((eval* clause) s)
                           (fn [evalled clause]
                             (flat-map evalled (fn [[do-next? s]]
                                                 (or (and do-next?
                                                          ((eval* clause) s))
                                                     (maybe [nothing s])))))))))))

(extend-type ast/or-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.clauses x))
         (partial .clauses x)))
  
  (eval* [x]
    (sm/new-sm (fn [s]
                 (let [[clause & clauses] (.clauses x)]
                   (reduce clauses ((eval* clause) s)
                           (fn [evalled clause]
                             (flat-map evalled (fn [v-s]
                                                 (let [[v] v-s]
                                                   (or (and v (maybe v-s))
                                                       ((eval* clause) s))))))))))))

(extend-type ast/assert-ast
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval* [assertion]
    ;; TODO: this needs to be completed
    (sm/state-maybe assertion)))

(extend-type ast/result-ast
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval* [assertion]
    ;; TODO: this needs to be completed
    (sm/state-maybe assertion))
  )

(extend-type ast/params-ast
  Evaluator
  (bind [x vs]
    (either (and (instance? Sequence vs)
                 (or (<= (count (.fixed x)) (count vs))
                     (do
                       (print-err "Not enough values in sequence to destructure")
                       (maybe (zero sm/state-maybe))))
                 (maybe (for [ys (traverse (zip-lists (seq (.fixed x)) vs)
                                            (fn [[target v]]
                                              (bind target v)))
                              _ (either (map (.variadic x)
                                             (fn [tail]
                                               (bind tail (drop (seq vs) (count (.fixed x))))))
                                        (sm/state-maybe '_))]
                          ys)))
            (do
              (print-err "Attempted to destructure a value that was not a List or a Vector")
              (zero sm/state-maybe)))))

(extend-type ast/let-ast
  Evaluator
  (eval-def [x]
    (for [new-bindings (eval-def (.bindings x))
          new-body (eval-def (.body x))]
      (ast/let-ast new-bindings new-body)))
  
  (eval* [x]
    (for [curr-state (sm/new-sm (fn [s] (maybe [s s])))
          results (eval* (comp (.bindings x) (.body x)))
          _ (sm/new-sm (fn [_] (maybe [curr-state curr-state])))]
      (reduce results '_ (fn [_ x] x)))))

(extend-type ast/binding-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.val x))
         (partial .val x)))

  (eval* [x]
    (flat-map (eval* (.val x))
              (partial bind (.binding x)))))

(extend-type ast/extend-ast
  Evaluator
  (eval* [x]
    (flat-map (comp (sm/get-in-val [.type-nums (.type x)])
                    (sm/new-sm (fn [s]
                                 (print-err "Could not extend type" (str "'" (.type x) "'") "at"
                                            (ast-location-str x))
                                 nothing)))
              (fn [type-map]
                (traverse (keys type-map)
                           (fn [type-num]
                             (comp (reify-impls (.impls x) type-num (ast-location-str x))
                                   (sm/state-maybe '_))))))))

(extend-type ast/type-ast
  Evaluator
  (eval* [x]
    (let [num-fields (count (.fields x))
          sym (untag (.sym x))]
      (for [type-nums (sm/get-val .type-nums)
            :let [type-num (count type-nums)
                  const-type (inc type-num)]
            _ (sm/assoc-in-val [.type-nums] (comp type-nums {(.sym x) {type-num #{}}
                                                             const-type {const-type #{}}}))
            _ (sm/assoc-in-val [.implementations 'string-list 1 const-type]
                               (fn [c]
                                 (list (str (either (.type-sym c) (.type-num c))))))
            _ (sm/assoc-in-val [.implementations 'invoke (inc num-fields) const-type]
                               (fn [_ & fields]
                                 (ReifiedValue (maybe (.sym x)) type-num (vec fields) (.fields x))))
            _ (sm/assoc-in-val [.implementations 'instance? 2 const-type]
                               (fn [constructor v]
                                 (and (= type-num (either (map (instance? ReifiedValue v) .type-num)
                                                          (get-type v)))
                                      (maybe v))))
            _ (sm/assoc-in-val [.syms sym] (ReifiedValue (-> (str "*" sym " constructor*") symbol maybe)
                                                              const-type [] []))
            _ (traverse (remove (.impls x) (partial instance? ast/assert-ast))
                         (fn [impls]
                           (reify-impls impls type-num (ast-location-str x))))]
        '_))))

(extend-type ast/main-ast
  Evaluator
  (eval* [x]
    ;; TODO: bind the arg list
    (eval* (.body x))))

(extend-type ast/quoted-ast
    Evaluator
    (eval-def [x]
      (sm/state-maybe x))

    (eval* [x]
      (sm/state-maybe (.q-val x))))

(extend-type Integer
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval* [x]
    (sm/state-maybe x)))

(extend-type Symbol
  Evaluator
  (eval-def [x]
    (comp (sm/get-in-val [.syms x])
          (sm/state-maybe x)))

  (eval* [x]
    (comp (sm/get-in-val [.syms x])
          (sm/new-sm (fn [s]
                       (print-err "Could not find definition for symbol" (str "'" x "'") "at"
                                  (ast-location-str x))
                       nothing)))))

(extend-type String
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval* [x]
    (sm/state-maybe x)))

(extend-type Function
  Evaluator
  (eval* [f]
    (sm/state-maybe f))

  (apply-fn [f args]
    (sm/state-maybe (apply f (seq args)))))


(extend-type ast/block-comment-ast
  Evaluator
  (eval* [x]
    (sm/state-maybe "")))

;; (extend-type ast/inline-ast
;;     Evaluator
;;     (eval* [x]
;;       (zero sm/state-maybe)))

;; (extend-type ast/module-ast
;;   Evaluator
;;   (eval* [x]
;;     ))

;; (extend-type ast/git-dep-ast
;;   Evaluator
;;   (eval* [x]
;;     ))

;; (extend-type ast/add-ns-ast
;;   Evaluator
;;   (eval* [x]
;;     ))

;; (extend-type ast/declaration-ast
;;   Evaluator
;;   (eval* [x]
;;     ))
