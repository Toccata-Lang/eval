(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "6b65dea"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "be57226"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "cb55c51"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "dc80090"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "f7b5678"))

(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))

(def *max-call-depth* 500)

(defn abort-interp [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               nothing)))

;; useful for debugging
(defn debug [& args]
  (sm/new-sm (fn [s]
               (apply print-err args)
               (maybe ['_ s]))))

(defn ast-location-str [x]
  (str (ast/file-name x) ": "
       (ast/line-number x)))

(deftype EvalNamespace [path imports syms impls]
  (assert (instance? HashMap imports))
  (assert (instance? HashMap syms))
  (assert (instance? HashMap impls)))

(deftype EvalState [ns type-count file-name call-depth command-line script-dir base-imports]
  (assert (instance? HashMap ns))
  (assert (instance? Integer type-count))
  (assert (instance? String file-name))
  (assert (instance? Integer call-depth))
  (assert (instance? Vector command-line))

  Stringable
  (string-list [_] (list "<EvalState>")))

(def empty-state (EvalState {} 0 "" 0 [] "" {}))

(defn get-syms []
  (flat-map (sm/get-val .file-name)
            (fn [ns-path]
              (sm/get-in-val [.ns ns-path .syms]))))


(defn set-syms [syms]
  (flat-map (sm/get-val .file-name)
            (fn [ns-path]
              (sm/assoc-in-val [.ns ns-path .syms] syms))))

(defprotocol Evaluator
  (untag [s]
    ;; remove the tag information from a symbol
    s)

  (update-state [x _]
    x)

  (traverse [coll f]
    ;; traverses a Sequence, applying 'f' to each item
    ;; 'f' must take one value and return a 'state-maybe' value
    (assert-result x (instance? sm/new-sm x)))

  (bind [_ _]
    ;; bind a value to a symbol in the .syms field of the current namespace
    ;; also destructures a params-ast to a sequence of values
    (assert-result r (instance? sm/state-maybe r)))

  (uniqueify [_]
    ;; replace arguments with unique symbols
    (assert-result r (instance? sm/state-maybe r)))

  (bind-fields [_]
    ;; bind the fields of a ReifiedValue to the field names
    (assert-result r (instance? sm/state-maybe r))
    (sm/state-maybe '_))

  (lookup-sym [s]
    ;; retrieve the value bound to 's'
    (assert-result r (instance? sm/state-maybe r)))

  (apply-fn [f args]
    ;; evaluate 'f' given paramters bound to 'args'
    (assert-result r (instance? sm/state-maybe r)))

  (eval-def [x]
    (assert-result r (instance? sm/state-maybe r)))

  (eval [x]
    ;; evaluate an expression 'x' to produce a value (and side effects)
    (assert-result r (instance? sm/state-maybe r))
    (sm/state-maybe x)))

(def parse (rd/parser
            (grmr/all (grmr/optional rdr/shebang)
                      (grmr/none-or-more
                       (grmr/any rdr/read-def
                                 rdr/read-defn
                                 rdr/read-defprotocol
                                 rdr/read-main
                                 rdr/read-extend-type
                                 rdr/read-deftype
                                 rdr/read-block-comment
                                 rdr/read-add-ns
                                 rdr/read-expr)))))

(extend-type CoreTypes
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval [x]
    (sm/state-maybe x)))

(deftype Thunk [ast es]
  Stringable
  (string-list [_]
    (list "<Thunk " (str ast) ">"))

  Evaluator
  (update-state [x new-state]
    (Thunk ast new-state))

  (apply-fn [_ args]
    (apply-fn ast args))

  (eval [t]
    (for [curr-state (sm/update-state identity)]
      (fn [& args]
        (-> t
            (update-state curr-state)
            (apply args)))))

  Container
  (apply [_ args]
    (either (flat-map ((apply-fn ast args) es)
                      first)
            (abort)))

  Function
  (invoke [v]
    (either (flat-map ((apply-fn ast []) es)
                      first)
            (abort)))

  (invoke [v a]
    (either (flat-map ((apply-fn ast [a]) es)
                      first)
            (abort)))

  (invoke [v a b]
    (either (flat-map ((apply-fn ast [a b]) es)
                      first)
            (abort)))

  (invoke [v a b c]
    (either (flat-map ((apply-fn ast [a b c]) es)
                      first)
            (abort)))

  (invoke [v a b c d]
    (either (flat-map ((apply-fn ast [a b c d]) es)
                      first)
            (abort)))

  (invoke [v a b c d e]
    (either (flat-map ((apply-fn ast [a b c d e]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f]
    (either (flat-map ((apply-fn ast [a b c d e f]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f g]
    (either (flat-map ((apply-fn ast [a b c d e f g]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f g h]
    (either (flat-map ((apply-fn ast [a b c d e f g h]) es)
                      first)
            (abort))))

(deftype ProtoDispatcher [prototype-name path es]
  (assert (instance? rdr/tagged-symbol prototype-name))
  (assert (instance? String path))
  (assert (instance? EvalState es))

  Type
  (type-name [_]
    (str "ProtoDispatcher: " prototype-name))

  Stringable
  (string-list [_]
    (list (str prototype-name)))

  Container
  (apply [disp args]
    (either (flat-map ((apply-fn disp args) es)
                      first)
            (abort)))

  Function
  (invoke [v]
    (either (flat-map ((apply-fn v []) es)
                      first)
            (abort)))

  (invoke [v a]
    (either (flat-map ((apply-fn v [a]) es)
                      first)
            (abort)))

  (invoke [v a b]
    (either (flat-map ((apply-fn v [a b]) es)
                      first)
            (abort)))

  (invoke [v a b c]
    (either (flat-map ((apply-fn v [a b c]) es)
                      first)
            (abort)))

  (invoke [v a b c d]
    (either (flat-map ((apply-fn v [a b c d]) es)
                      first)
            (abort)))

  (invoke [v a b c d e]
    (either (flat-map ((apply-fn v [a b c d e]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f]
    (either (flat-map ((apply-fn v [a b c d e f]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f g]
    (either (flat-map ((apply-fn v [a b c d e f g]) es)
                      first)
            (abort)))

  (invoke [v a b c d e f g h]
    (either (flat-map ((apply-fn v [a b c d e f g h]) es)
                      first)
            (abort)))

  Evaluator
  (update-state [x new-state]
    (.es x new-state))

  (eval-def [x]
    (sm/state-maybe x))
  
  (eval [x]
    (sm/state-maybe x))

  (apply-fn [_ args]
    (let [num-args (count args)]
      (either (and (empty? args)
                   (maybe (abort-interp "At least one argument must be passed to protocol function"
                                 (str "'" prototype-name "'"))))
              (let [[disp-arg] args
                    disp-arg (untag disp-arg)]
                (for [impl (comp (sm/get-in-val [.ns path .impls prototype-name num-args (get-type disp-arg)])
                                 (sm/get-in-val [.ns path .impls prototype-name num-args 0])
                                 (abort-interp "Could not find implementation of"
                                               (str "'" prototype-name "'") "with"
                                               num-args
                                               "arguments for type"
                                               (str "'" (type-name disp-arg) ".")))
                      syms (get-syms)
                      _ (bind-fields disp-arg)
                      r (apply-fn impl (comp [disp-arg] (rest args)))
                      _ (set-syms syms)]
                  r))))))

(defn new-protocol [sym]
  (comp (flat-map (lookup-sym sym)
                  (fn [_]
                    (abort-interp "Trying to redefine a protocol named"
                                  (str "'" sym "'"))))
        (sm/state-maybe '_)))

(defn set-impl [sym num-args type-num impl]
  (flat-map (lookup-sym sym)
            (fn [disp]
              (sm/assoc-in-val [.ns (.path disp) .impls (.prototype-name disp) num-args type-num]
                               impl))))

(defn get-impl [sym num-args type-num]
  (for [disp (lookup-sym sym)
        _ (either (map (instance? ProtoDispatcher disp) sm/state-maybe)
                  (abort-interp (str "'" sym "'") "is not a protocol function."))
        result (sm/get-in-val [.ns (.path disp) .impls (.prototype-name disp)
                              num-args type-num])]
    result))

(defn invoke-reified [rv & args]
  (either (flat-map ((for [impl (get-impl (rdr/tag 'invoke) (inc (count args)) (.type-num rv))
                           _ (bind-fields rv)
                           result (apply-fn impl (cons rv args))]
                       result)
                     (.es rv))
                    first)
          (abort)))

(defn sha1-update-type-num [type-num ctxt]
  (assert (instance? Integer type-num))
  (inline C Integer "
  Sha1Update(((Opaque *)ctxt_1)->ptr, (void *)&((Integer *)type_num_0)->numVal, 8);
  dec_and_free(type_num_0, 1);
  return(ctxt_1);
"))

(deftype ReifiedValue [type-sym type-num fields field-names es]
  (assert (instance? Maybe type-sym))
  (assert (instance? Integer type-num))
  (assert (instance? Vector fields))
  (assert (instance? params-ast fields))
  (assert (instance? EvalState es))

  Function
  (invoke [v]
    (invoke-reified v))

  (invoke [v a]
    (invoke-reified v a))

  (invoke [v a b]
    (invoke-reified v a b))

  (invoke [v a b c]
    (invoke-reified v a b c))

  (invoke [v a b c d]
    (invoke-reified v a b c d))

  (invoke [v a b c d e]
    (invoke-reified v a b c d e))

  (invoke [v a b c d e f]
    (invoke-reified v a b c d e f))

  (invoke [v a b c d e f g]
    (invoke-reified v a b c d e f g))

  (invoke [v a b c d e f g h]
    (invoke-reified v a b c d e f g h))

  Container
  (apply [v args]
    (either (flat-map ((for [impl (get-impl (rdr/tag 'apply) 2 type-num)
                             _ (bind-fields v)
                             result (apply-fn impl [v (seq args)])]
                         result)
                       es)
                      first)
            (abort)))

  Hashable
  (sha1-update [x ctxt]
    (sha1-update-type-num (get-type x) ctxt)
    (sha1-update fields ctxt))

  (sha1 [v]
    (either (flat-map ((for [impl (get-impl (rdr/tag 'sha1) 1 type-num)
                             _ (bind-fields v)
                             result (apply-fn impl [v])]
                         result)
                       es)
                      first)
            (sha1-finalize (sha1-update v (sha1-init)))))

  Eq
  (=* [x y]
    (either (flat-map ((for [args (eval (list x y))
                             impl (get-impl (rdr/tag '=*) 2 type-num)
                             _ (bind-fields x)
                             r (apply-fn impl args)]
                         r)
                       es)
                      first)
            (and (= type-num (get-type y))
                 (= fields (type-args y))
                 (maybe x))))

  Type
  (type-args [_]
    fields)

  (type-name [_]
    (either (map type-sym str)
            (str type-num)))

  (get-type [_]
    type-num)

  Stringable
  (string-list [v]
    (either (flat-map ((for [impl (get-impl (rdr/tag 'string-list) 1 type-num)
                             _ (bind-fields v)
                             result (apply-fn impl [v])]
                         result)
                       es)
                      first)
            (list "<" (str (either type-sym "reified"))
                  " " (apply str (seq fields)) ">")))

  Evaluator
  (update-state [x new-state]
    (.es x new-state))

  (eval [x]
    (for [curr-state (sm/update-state identity)]
      (.es x curr-state)))

  (apply-fn [disp-arg args]
    (let [num-args (inc (count args))]
      (flat-map (comp (get-impl (rdr/tag 'invoke) num-args type-num)
                      (get-impl (rdr/tag 'invoke) num-args 0))
                (fn [impl]
                  (apply-fn impl (cons disp-arg (seq args)))))))

  (bind-fields [_]
    (either (and (empty? fields)
                 (maybe (sm/state-maybe '_)))
            (traverse (zip-lists (seq field-names) (seq fields))
                      (fn [[name value]]
                        (bind name value))))))

(deftype TypeMap [type-map]
  Stringable
  (string-list [_]
    (list "<TypeMap " (str type-map) ">"))

  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval [x]
    (sm/state-maybe x))

  Composition
  (comp* [x xs]
    (TypeMap (comp* type-map (map xs type-mapping))))

  Type
  (instance? [_ v]
    (or (and (get type-map FunctionType)
             (or (instance? ast/fn-ast v)
                 (instance? Thunk v)))
        (and (get type-map (get-type v))
             (maybe v)))))

(deftype TypeConstructor [type-sym type-num reified-type field-names type-map]
  (assert (instance? rdr/tagged-symbol type-sym))
  (assert (instance? Integer type-num))
  (assert (instance? HashMap type-map))

  Type
  (instance? [_ v]
    (and (= reified-type (get-type v))
         (maybe v)))

  (type-name [_]
    (str  "*" type-sym " constructor*"))

  Stringable
  (string-list [_]
    (list "<TypeCon " (str type-sym) " " (str field-names) ">"))

  Evaluator
  (eval [x]
    (sm/state-maybe x))

  (apply-fn [f args]
    (for [s (sm/update-state identity)]
      (ReifiedValue (maybe type-sym)
                    reified-type
                    (vec args) field-names s)))

  Composition
  (comp* [x xs]
    (TypeMap (comp* type-map (map xs type-mapping)))))

(extend-type List
  Evaluator
  (traverse [asts f]
    (apply (sm/state-maybe list)
           (-> asts
               (remove (partial instance? ast/block-comment-ast))
               (map f))))

  (eval-def [v]
    (traverse v eval-def))

  (eval [v]
    (traverse v eval)))

(extend-type Vector
  Evaluator
  (traverse [asts f]
    (-> asts
        (remove (partial instance? ast/block-comment-ast))
        reverse
        (reduce (sm/state-maybe empty-vector)
                (fn [v ast]
                  (flat-map (f ast)
                            (fn [emitted]
                              (map v (fn [v]
                                       (conj v emitted)))))))
        (map reverse)))

  (eval-def [v]
    (traverse v eval-def))

  (eval [v]
    (traverse v eval)))

(defn define-sum-type [asts sym]
  (assert (instance? rdr/tagged-symbol sym))

  (for [ast (sm/when (some asts (partial instance? ast/call-ast)))
        :when (= (.call-target ast) 'comp*)
        :let [[arg & args] (.args ast)
              args (either (for [args-list (first args)
                                 :when (instance? ast/call-ast args-list)]
                             (.args args-list))
                           empty-list)]
        :when (instance? rdr/tagged-symbol arg)
        type-map (lookup-sym arg)
        type-maps (traverse args (fn [arg]
                                   (comp (lookup-sym arg)
                                         (abort-interp "Could not find type definition for"
                                                (str "'" arg "'") "at"
                                                (ast-location-str arg)))))
        _ (bind sym (comp* type-map type-maps))]
    '_))

(defn definition-value [asts sym]
  (assert (instance? rdr/tagged-symbol sym))

  (comp (define-sum-type asts sym)
        (for [_ (sm/get-in-val [.ns "" .syms (.base sym)])]
          (print-err "Redefining symbols from the core namespace is not allowed."
                     (str "'" sym "'") "cannot be defined at"
                     (ast-location-str asts) "\n"))
        (flat-map (eval asts)
                  (fn [values]
                    (either (and (empty? values)
                                 (maybe (abort-interp "No valid value given for defintion of"
                                                      (str "'" sym "' at" (ast-location-str asts)))))
                            (bind sym (reduce values '_ (fn [_ x] x))))))))

(extend-type ast/definition-ast
  Evaluator
  (eval [x]
    (let [sym (.sym x)]
      (comp (-> (.value-exprs x)
                (filter (fn [ast]
                          (or (instance? ast/CodeAST ast)
                              (instance? rdr/tagged-symbol ast)
                              (instance? ast/fn-ast ast))))
                (remove (partial instance? ast/inline-ast))
                (definition-value sym))
            (sm/new-sm (fn [s]
                         (print-err "Could not evaluate definition for" (str "'" sym "'") "at:"
                                    (ast-location-str x) "\n")
                         (maybe ['_ s])))))))

(def FnBodyAST (comp CoreTypes
                     ast/CodeAST
                     rdr/tagged-symbol
                     ast/fn-ast))

(extend-type ast/fn-ast
  Evaluator
  (eval [x]
    (for [new-arities (eval-def (.arities x))
          curr-file (sm/get-val .file-name)
          curr-state (sm/update-state identity)]
      (let [fn-sym (either (.fn-sym x)
                           (rdr/tag 'anon))
            new-fn-sym (or (.ns fn-sym)
                           (maybe (.ns fn-sym (maybe curr-file))))]
        (-> x
            (.arities new-arities)
            (.fn-sym new-fn-sym)
            (Thunk curr-state)))))

  (eval-def [x]
    (for [new-arities (eval-def (.arities x))
          curr-state (sm/update-state identity)]
      (Thunk (.arities x new-arities) curr-state)))

  (apply-fn [x args]
    (let [num-args (count args)
          arity? (reduce (.arities x) nothing
                         (fn [found arity]
                           (or (and (= num-args (-> arity .params .fixed count))
                                    (= nothing (-> arity .params .variadic))
                                    (maybe arity))
                               found
                               (and (-> arity .params .variadic)
                                    (<= (-> arity .params .fixed count) num-args)
                                    (maybe arity)))))]
      (either (map arity?
                   (fn [arity]
                     (let [body (filter (.body arity) (partial instance? FnBodyAST))]
                       (either (map (empty? body)
                                    (fn [_]
                                      (abort-interp "Invalid function body at" (ast-location-str x))))
                               (comp (for [syms (get-syms)
                                           curr-file (sm/get-val .file-name)
                                           _ (comp (for [ns-sym (sm/when (for [fn-sym (.fn-sym x)
                                                                               :when (instance? rdr/tagged-symbol fn-sym)
                                                                               ns (.ns fn-sym)]
                                                                           ns))
                                                         new-syms (sm/get-in-val [.ns curr-file .imports ns-sym])
                                                         _ (set-syms new-syms)]
                                                     '_)
                                                   (sm/state-maybe '_))
                                           _ (bind (.params arity) args)
                                           result (map (eval body) (fn [results]
                                                                     (reduce results '_ (fn [_ x] x))))
                                           result (either (map (instance? ast/fn-ast result) eval-def)
                                                          (sm/state-maybe result))
                                           _ (set-syms syms)]
                                       result)
                                     (abort-interp "Could not evaluate function"
                                                   (str "'" (either (.fn-sym x) "<anon>") "'")
                                                   "at" (ast-location-str (.fn-sym x))))))))
              (abort-interp "No arity found for" (str "'" (either (.fn-sym x) "<anon>") "'") "with"
                            num-args "arguments.")))))

(extend-type ast/fn-arity-ast
  Evaluator
  (eval-def [x]
    (for [syms (get-syms)
          new-params (uniqueify (.params x))
          new-body (eval-def (.body x))
          _ (set-syms syms)]
      (-> x
          (.params new-params)
          (.body new-body)))))

(defn set-default-impl [fn-sym params body]
  (let [num-args (count params)]
    (either (-> body
                (filter (partial instance? FnBodyAST))
                (empty?)
                (map (fn [_]
                       (sm/state-maybe '_))))
            (comp (get-impl fn-sym num-args 0)
                  (flat-map (eval (ast/fn-ast (maybe fn-sym)
                                               [(ast/fn-arity-ast fn-sym "" params ""
                                                                  body)]))
                            (partial set-impl fn-sym num-args 0))))))

(extend-type ast/prototype-ast
  Evaluator
  (eval [prototype]
    (either (and (flat-map (instance? rdr/tagged-symbol (.fn-name prototype))
                           .ns)
                 (let [fn-sym (.fn-name prototype)]
                   (maybe (abort-interp "The protcol function name" (str "'" fn-sym "'")
                                        "is invalid because it has the prefix"
                                        (str "'" (-> fn-sym .ns extract) "/'")
                                        "at" (ast-location-str fn-sym)))))
            (let [fn-sym (.fn-name prototype)
                  params (.params prototype)]
              (comp (for [disp (lookup-sym fn-sym)
                          :when-not (instance? ProtoDispatcher disp)]
                      (print-err "Attempt to redefine" (str "'" fn-sym "'")
                                 "as a protocol function at" (ast-location-str prototype)
                                 "failed. Kept existing definition."))
                    (for [curr-file-name (sm/get-val .file-name)
                          _ (comp (lookup-sym fn-sym)
                                  (bind fn-sym (ProtoDispatcher fn-sym curr-file-name
                                                                empty-state)))
                          _ (set-default-impl fn-sym params (.default-body prototype))]
                      '_))))))

(extend-type ast/protocol-ast
  Evaluator
  (eval [x]
    (let [proto-sym (.protocol-sym x)]
      (for [_ (new-protocol proto-sym)
            curr-file-name (sm/get-val .file-name)
            _ (traverse (.prototypes x) eval)]
        '_))))

(defn wrap-arity [fn-arity fn-name]
  (assert (instance? String fn-name))
  (inline C "
   FnArity *arity = (FnArity *)fn_arity_0;
   Function *f = malloc_function(1);
   if (fn_name_1->type == StringBufferType) {
     String *s = (String *)fn_name_1;
     f->name = malloc(s->len + 3);
     snprintf(f->name, s->len + 1, \"%s\", s->buffer);
   } else if (fn_name_1->type == SubStringType) {
     SubString *s = (SubString *)fn_name_1;
     f->name = malloc(s->len + 3);
     snprintf(f->name, s->len + 1, \"%s\", s->buffer);
   }
   f->arityCount = 1;
   f->arities[0] = arity;
   dec_and_free(fn_name_1, 1);
   return((Value *)f);"))

(defn reify-impls [impls type-num location]
  (assert (instance? HashMap impls))

  (traverse (seq impls)
            (fn [[protocol proto-impls]]
              (traverse (for [[fn-sym impl-arities] (seq proto-impls)
                              arity impl-arities]
                          [fn-sym arity])
                        (fn [[fn-sym arity]]
                          (let [num-args (count (.params arity))]
                            (comp (get-impl fn-sym num-args type-num)
                                  (flat-map (eval-def arity)
                                            (fn [new-arity] 
                                              (set-impl fn-sym num-args type-num
                                                        (ast/fn-ast (maybe fn-sym) [new-arity]))))
                                  (abort-interp "Could not reify an implementation of"
                                         (str "'" fn-sym "'") "at" (ast-location-str arity)))))))))

(extend-type ast/reify-ast
  Evaluator
  (eval-def [x]
    (eval x))

  (eval [x]
    (for [type-num (sm/get-val .type-count)
          _ (sm/set-val .type-count (inc type-num))
          _ (reify-impls (.impls x) type-num (ast-location-str x))
          _ (set-impl (rdr/tag '=*) 2 type-num (fn [x y]
                                                 (and (=* (get-type x) (get-type y))
                                                      (maybe x))))]
      (ReifiedValue (maybe (str "reified at: " (ast-location-str x))) type-num [] [] empty-state))))

(extend-type ast/call-ast
  Evaluator
  (eval [x]
    (for [curr-syms (get-syms)
          call-depth (sm/get-val .call-depth)
          _ (either (map (< call-depth *max-call-depth*) sm/state-maybe)
                    (abort-interp "Recursion limit exceeded at" (ast-location-str x)))
          _ (sm/set-val .call-depth (inc call-depth))
          args (eval (.args x))
          _ (set-syms curr-syms)
          target (eval (.call-target x))
          r (apply-fn target args)
          _ (sm/set-val .call-depth call-depth)]
      r))

  (eval-def [ast]
    (for [target (eval-def (.call-target ast))
          args (eval-def (.args ast))]
      (ast/call-ast target args))))

(extend-type ast/either-ast
  Evaluator
  (eval-def [x]
    (for [new-clause (eval-def (.clause x))
          new-alt (eval-def (.alt x))]
      (ast/either-ast new-clause new-alt)))

  (eval [x]
    (sm/new-sm (fn [s]
                 (flat-map ((eval (.clause x)) s)
                           (fn [v-s]
                             (let [[v?] v-s]
                               (or (map v? (fn [v] [v s]))
                                   ((eval (.alt x)) s)))))))))

(extend-type ast/and-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.clauses x))
         (partial .clauses x)))

  (eval [x]
    (sm/new-sm (fn [s]
                 (let [[clause & clauses] (.clauses x)]
                   (reduce clauses ((eval clause) s)
                           (fn [evalled clause]
                             (flat-map evalled (fn [[do-next? s]]
                                                 (or (and do-next?
                                                          ((eval clause) s))
                                                     (maybe [nothing s])))))))))))

(extend-type ast/or-ast
  Evaluator
  (eval-def [x]
    (map (eval-def (.clauses x))
         (partial .clauses x)))

  (eval [x]
    (sm/new-sm (fn [s]
                 (let [[clause & clauses] (.clauses x)]
                   (reduce clauses ((eval clause) s)
                           (fn [evalled clause]
                             (flat-map evalled (fn [v-s]
                                                 (let [[v] v-s]
                                                   (or (and v (maybe v-s))
                                                       ((eval clause) s))))))))))))

(extend-type ast/assert-ast
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval [assertion]
    ;; TODO: this needs to be completed
    (sm/state-maybe assertion)))

(extend-type ast/result-ast
  Evaluator
  (eval-def [x]
    (sm/state-maybe x))

  (eval [assertion]
    ;; TODO: this needs to be completed
    (sm/state-maybe assertion)))
  

(extend-type ast/params-ast
  Evaluator
  (uniqueify [x]
    ;; replace arguments with unique symbols
    (for [new-fixed (traverse (.fixed x) uniqueify)
          new-variadic (comp (flat-map (sm/when (.variadic x))
                                       (fn [arg]
                                         (map (uniqueify arg) maybe)))
                             (sm/state-maybe nothing))]
      (ast/params-ast new-fixed new-variadic)))

  (bind [x vs]
    (let [vs (seq vs)]
      (either (and (instance? Sequence vs)
                   (or (<= (count (.fixed x)) (count vs))
                       (do
                         (print-err "Not enough values in sequence to destructure")
                         (maybe (zero sm/state-maybe))))
                   (maybe (for [ys (traverse (zip-lists (seq (.fixed x)) vs)
                                             (fn [[target v]]
                                               (bind target v)))
                                _ (either (map (.variadic x)
                                               (fn [tail]
                                                 (bind tail (drop vs (count (.fixed x))))))
                                          (sm/state-maybe '_))]
                            ys)))
              (abort-interp "Attempted to destructure a value that was not a List or a Vector")))))

(extend-type ast/let-ast
  Evaluator
  (eval-def [x]
    (for [syms (get-syms)
          new-bindings (eval-def (.bindings x))
          new-body (eval-def (.body x))
          _ (set-syms syms)]
      (ast/let-ast new-bindings new-body)))

  (eval [x]
    (for [curr-state (sm/new-sm (fn [s] (maybe [s s])))
          results (eval (comp (.bindings x) (.body x)))
          _ (sm/new-sm (fn [_] (maybe [curr-state curr-state])))]
      (reduce results '_ (fn [_ x] x)))))

(extend-type ast/binding-ast
  Evaluator
  (eval-def [x]
    (for [v (eval-def (.val x))
          new-binding (uniqueify (.binding x))]
      (ast/binding-ast new-binding v)))

  (eval [x]
    (flat-map (eval (.val x))
              (partial bind (.binding x)))))

(extend-type ast/extend-ast
  Evaluator
  (eval [x]
    (flat-map (comp (lookup-sym (.type x))
                    (abort-interp "Could not extend type" (str "'" (.type x) "'") "at"
                           (ast-location-str x)))
              (fn [type]
                (traverse (keys (type-mapping type))
                          (fn [type-num]
                            (comp (reify-impls (.impls x) type-num (ast-location-str x))
                                  (sm/state-maybe '_))))))))

(defn create-constructor [sym fields const-type type-num]
  (for [_ (set-impl (rdr/tag 'invoke) (inc (count fields)) const-type
                    (fn [_ & field-values]
                      (ReifiedValue (maybe sym) type-num (vec field-values) fields empty-state)))
        _ (set-impl (rdr/tag 'instance?) 2 const-type
                    (fn [constructor v]
                      (and (= type-num (get-type v))
                           (maybe v))))

        _ (bind sym (TypeConstructor sym const-type type-num (-> fields .fixed)
                                     {type-num (-> fields .fixed set)}))]
    '_))

(defn set-type-impls [x type-num]
  (let [sym (.sym x)
        field-indices (reduce (zip-lists (seq (-> x .fields .fixed))
                                         (range (count (.fields x))))
                              {} (fn [m [field-name index]]
                                   (assoc m (rdr/tag (symbol (str "." field-name))) index)))]
    (for [_ (traverse (remove (.impls x) (partial instance? ast/assert-ast))
                      (fn [impls]
                        (reify-impls impls type-num (ast-location-str x))))
          _ (traverse (seq field-indices)
                      (fn [[getter-sym field-idx]]
                        (for [_ (comp (lookup-sym getter-sym)
                                      (bind getter-sym (ProtoDispatcher getter-sym "" empty-state)))
                              _ (set-impl getter-sym 1 type-num (fn [x]
                                                                  (assert (instance? ReifiedValue x))
                                                                  (-> x
                                                                      (type-args)
                                                                      (nth field-idx)
                                                                      (extract))))
                              _ (set-impl getter-sym 2 type-num (fn [x new-field]
                                                                  (assert (instance? ReifiedValue x))
                                                                  (.fields x (-> x
                                                                                 (type-args)
                                                                                 (store field-idx new-field)
                                                                                 (extract)))))]
                          '_)))
          _ (set-impl (rdr/tag 'get-type) 1 type-num get-type)
          _ (set-impl (rdr/tag 'type-name) 1 type-num type-name)
          _ (set-impl (rdr/tag 'type-args) 1 type-num type-args)
          _ (comp (get-impl (rdr/tag 'get) 2 type-num)
                  (set-impl (rdr/tag 'get) 2 type-num
                            (fn [v field]
                              (assert (instance? ReifiedValue v))
                              (for [disp (instance? ProtoDispatcher field)
                                    index (get field-indices (.prototype-name disp))
                                    field (get (type-args v) index)]
                                field))))
          _ (comp (get-impl (rdr/tag 'assoc) 3 type-num)
                  (set-impl (rdr/tag 'assoc) 3 type-num
                            (fn [v field new-field-value]
                              (assert (instance? ReifiedValue v))
                              (either (for [disp (instance? ProtoDispatcher field)
                                            index (get field-indices (.prototype-name disp))
                                            new-fields (store (type-args v) index new-field-value)]
                                        (.fields v new-fields))
                                      v))))]
      '_)))

(extend-type ast/type-ast
  Evaluator
  (eval [x]
    (let [num-fields (count (.fields x))
          sym (.sym x)]
      (either (for [_ (and (instance? rdr/tagged-symbol (.sym x))
                           (-> x .sym .ns))]
                (abort-interp "A new type may not be defined with a namespace qualified symbol."
                       (str "'" (.sym x) "' is invalid at" (ast-location-str x))))
              (for [type-num (sm/get-val .type-count)
                    :let [const-type (inc type-num)]
                    _ (sm/set-val .type-count (inc const-type))
                    _ (set-type-impls x type-num)
                    _ (create-constructor sym (.fields x) const-type type-num)]
                '_)))))

(extend-type ast/main-ast
  Evaluator
  (eval [x]
    (for [cmd-line (sm/get-val .command-line)
          curr-syms (get-syms)
          _ (bind (.params x) [cmd-line])
          result (eval (.body x))
          _ (set-syms curr-syms)]
      result)))

(extend-type ast/quoted-ast
    Evaluator
    (eval-def [x]
      (sm/state-maybe (untag (.q-val x))))

    (eval [x]
      (sm/state-maybe (untag (.q-val x)))))

(extend-type Symbol
  Evaluator
  (bind [sym v]
    (bind (rdr/tag sym) v)))

(extend-type rdr/tagged-symbol
  Evaluator
  (uniqueify [x]
    (either (and (.ns x)
                 (maybe (abort-interp "May not use a namespace-qualified symbol at"
                               (ast-location-str x))))
            (let [new-sym (rdr/tag (gensym (str x "_")))]
              (for [_ (bind x new-sym)]
                new-sym))))

  (lookup-sym [x]
    (for [curr-file (sm/get-val .file-name)
          curr-state (sm/update-state identity)
          r (either (map (.ns x)
                         (fn [ns-sym]
                           (sm/get-in-val [.ns curr-file .imports (rdr/tag ns-sym) (rdr/tag (.base x))])))
                    (comp (sm/get-in-val [.ns curr-file .syms x])
                          (sm/get-in-val [.ns "" .syms x])))]
      (update-state r curr-state)))

  (eval-def [x]
    (comp (lookup-sym x)
          (sm/state-maybe x)))

  (untag [x]
    (either (map (.ns x)
                 (fn [ns]
                   (symbol (str ns "/" (.base x)))))
            (.base x)))

  (eval [x]
    (comp (lookup-sym x)
          (sm/new-sm (fn [s]
                       (print-err "There is no value bound to" (str "'" x "' at")
                                  (ast-location-str x))
                       nothing))))

  (bind [x v]
    (either (and (.ns x)
                 (do
                   (print-err "A value can not be bound to a namespace-qualified symbol. At"
                              (str "'" (ast/file-name x) "',") (ast/line-number x))
                   (zero sm/state-maybe)))
            (flat-map (sm/get-val .file-name)
                      (fn [ns-path]
                        (sm/assoc-in-val [.ns ns-path .syms x] v))))))

(extend-type Fn
  Evaluator
  (apply-fn [f args]
    (sm/state-maybe (apply f (seq args)))))

(extend-type ast/block-comment-ast
  Evaluator
  (eval [x]
    (sm/state-maybe "")))

(extend-type ast/add-ns-ast
  Evaluator
  (eval [x]
    (for [curr-file (sm/get-val .file-name)
          mod-syms (eval (.mod x))
          _ (sm/assoc-in-val [.ns curr-file .imports (.ns-sym x)] mod-syms)
          _ (sm/set-val .file-name curr-file)]
      '_)))

(extend-type ast/declaration-ast
  Evaluator
  (eval [x]
    (sm/state-maybe '_)))
